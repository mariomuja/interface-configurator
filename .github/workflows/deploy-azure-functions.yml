name: Deploy Azure Functions

on:
  push:
    branches:
      - main
    paths:
      - 'azure-functions/**'
      - '.github/workflows/deploy-azure-functions.yml'
  workflow_dispatch:

env:
  AZURE_FUNCTIONAPP_NAME: func-appe1mz5h  # Will be updated from Terraform outputs
  AZURE_FUNCTIONAPP_PACKAGE_PATH: 'azure-functions/ProcessCsvBlobTrigger'
  DOTNET_VERSION: '8.0.x'

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: 'Checkout GitHub Action'
        uses: actions/checkout@v4

      - name: Setup .NET Core
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: 'Resolve Project Dependencies'
        shell: bash
        run: |
          cd './${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}'
          pwd
          ls -la
          echo "Restoring dependencies..."
          dotnet restore ProcessCsvBlobTrigger.csproj

      - name: 'Build .NET Function App'
        shell: bash
        run: |
          cd './${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}'
          echo "Building project..."
          dotnet build ProcessCsvBlobTrigger.csproj --configuration Release --no-restore

      - name: 'Publish .NET Function App'
        shell: bash
        run: |
          cd './${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}'
          echo "Publishing project..."
          dotnet publish ProcessCsvBlobTrigger.csproj --configuration Release --output ./publish --no-build

      - name: 'Create deployment package'
        shell: bash
        run: |
          cd './${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}/publish'
          # Verify required files exist
          echo "Checking required files..."
          ls -la host.json || echo "ERROR: host.json not found!"
          ls -la functions.metadata || echo "ERROR: functions.metadata not found!"
          ls -la ProcessCsvBlobTrigger.dll || echo "ERROR: ProcessCsvBlobTrigger.dll not found!"
          ls -la ProcessCsvBlobTrigger.Core.dll || echo "WARNING: ProcessCsvBlobTrigger.Core.dll not found (might be OK)"
          ls -la extensions.json || echo "WARNING: extensions.json not found"
          
          # Verify Core assembly is present
          if [ ! -f "ProcessCsvBlobTrigger.dll" ]; then
            echo "❌ ERROR: ProcessCsvBlobTrigger.dll is missing!"
            exit 1
          fi
          
          if [ ! -f "host.json" ]; then
            echo "❌ ERROR: host.json is missing!"
            exit 1
          fi
          
          if [ ! -f "functions.metadata" ]; then
            echo "❌ ERROR: functions.metadata is missing!"
            exit 1
          fi
          
          # Exclude unnecessary files to reduce package size
          echo "Cleaning up unnecessary files..."
          find . -name "Microsoft.CodeAnalysis*.dll" -delete || true
          find . -name "Microsoft.CodeAnalysis*.pdb" -delete || true
          find . -name "*.Designer.dll" -delete || true
          find . -name "*.Designer.pdb" -delete || true
          find . -name "*.xml" -delete || true
          find . -name "*.pdb" -delete || true
          find . -type d -name "runtimes" -exec rm -rf {} + 2>/dev/null || true
          
          # Create ZIP with all files (use absolute path to avoid issues)
          # Important: Create ZIP from current directory (publish folder) with all files
          ZIP_PATH="$(pwd)/../function-app.zip"
          echo "Creating ZIP from: $(pwd)"
          echo "ZIP will be created at: $ZIP_PATH"
          
          # List files before creating ZIP
          echo "Files to be included in ZIP:"
          find . -type f | head -20
          
          # Create ZIP - include all files from current directory
          zip -r "$ZIP_PATH" . -q
          cd ..
          
          echo "Package created at: $ZIP_PATH"
          echo "Package size: $(du -h function-app.zip | cut -f1)"
          echo ""
          echo "Package contents (first 50 files):"
          unzip -l function-app.zip | head -50
          
          # Verify ZIP contains critical files (check exact paths)
          echo ""
          echo "Verifying critical files in ZIP..."
          if unzip -l function-app.zip | grep -qE "(^|\s)host\.json(\s|$)"; then
            echo "✅ host.json found in ZIP"
          else
            echo "❌ ERROR: ZIP does not contain host.json!"
            echo "ZIP contents:"
            unzip -l function-app.zip | grep -i "host\|json" || true
            exit 1
          fi
          
          if unzip -l function-app.zip | grep -qE "(^|\s)functions\.metadata(\s|$)"; then
            echo "✅ functions.metadata found in ZIP"
          else
            echo "❌ ERROR: ZIP does not contain functions.metadata!"
            exit 1
          fi
          
          if unzip -l function-app.zip | grep -q "ProcessCsvBlobTrigger.dll"; then
            echo "✅ ProcessCsvBlobTrigger.dll found in ZIP"
          else
            echo "❌ ERROR: ZIP does not contain ProcessCsvBlobTrigger.dll!"
            echo "DLL files in ZIP:"
            unzip -l function-app.zip | grep "\.dll" | head -10 || true
            exit 1
          fi
          
          echo "✅ ZIP package verified successfully"

      - name: 'Azure Login'
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: 'Deploy to Azure Functions via Azure CLI'
        shell: bash
        run: |
          set -eo pipefail
          echo "Deploying ZIP package via Azure CLI..."
          
          ZIP_PATH="${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}/function-app.zip"
          
          # Verify ZIP file exists
          if [ ! -f "$ZIP_PATH" ]; then
            echo "❌ ERROR: ZIP file not found at $ZIP_PATH"
            exit 1
          fi
          
          echo "ZIP file size: $(du -h "$ZIP_PATH" | cut -f1)"
          echo "ZIP file absolute path: $(realpath "$ZIP_PATH")"
          
          # Verify ZIP file is valid
          echo "Verifying ZIP file integrity..."
          if ! unzip -t "$ZIP_PATH" > /dev/null 2>&1; then
            echo "❌ ERROR: ZIP file is corrupted or invalid!"
            exit 1
          fi
          echo "✅ ZIP file is valid"
          
          # List first few files in ZIP for debugging
          echo "First 30 files in ZIP:"
          unzip -l "$ZIP_PATH" | head -35
          
          # Check if critical files exist (with better pattern matching)
          echo ""
          echo "Checking for critical files..."
          ZIP_CONTENTS=$(unzip -l "$ZIP_PATH")
          
          if echo "$ZIP_CONTENTS" | grep -qE "(^|\s)host\.json(\s|$)"; then
            echo "✅ host.json found in ZIP"
          else
            echo "❌ ERROR: host.json not found in ZIP!"
            echo "Files containing 'host' or 'json':"
            echo "$ZIP_CONTENTS" | grep -i "host\|json" || echo "None found"
            exit 1
          fi
          
          if echo "$ZIP_CONTENTS" | grep -q "ProcessCsvBlobTrigger.dll"; then
            echo "✅ ProcessCsvBlobTrigger.dll found in ZIP"
          else
            echo "❌ ERROR: ProcessCsvBlobTrigger.dll not found in ZIP!"
            echo "DLL files in ZIP:"
            echo "$ZIP_CONTENTS" | grep "\.dll" | head -10 || echo "None found"
            exit 1
          fi
          
          if echo "$ZIP_CONTENTS" | grep -qE "(^|\s)functions\.metadata(\s|$)"; then
            echo "✅ functions.metadata found in ZIP"
          else
            echo "⚠️  WARNING: functions.metadata not found in ZIP"
          fi
          
          echo "Deploying to Function App: ${{ env.AZURE_FUNCTIONAPP_NAME }}"
          echo "Resource Group: rg-infrastructure-as-code"
          
          # CRITICAL: Remove WEBSITE_RUN_FROM_PACKAGE and WEBSITE_USE_ZIP if they exist
          # These settings block ZIP deployment
          echo "Checking for blocking app settings..."
          ALL_SETTINGS=$(az functionapp config appsettings list \
            --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
            --resource-group rg-infrastructure-as-code \
            --output json 2>/dev/null || echo "[]")
          
          RUN_FROM_PACKAGE=$(echo "$ALL_SETTINGS" | jq -r '.[] | select(.name=="WEBSITE_RUN_FROM_PACKAGE") | .value' 2>/dev/null || echo "")
          USE_ZIP=$(echo "$ALL_SETTINGS" | jq -r '.[] | select(.name=="WEBSITE_USE_ZIP") | .value' 2>/dev/null || echo "")
          
          if [ -n "$RUN_FROM_PACKAGE" ] && [ "$RUN_FROM_PACKAGE" != "null" ] && [ "$RUN_FROM_PACKAGE" != "" ]; then
            echo "⚠️  WEBSITE_RUN_FROM_PACKAGE is set to: $RUN_FROM_PACKAGE"
            echo "Removing WEBSITE_RUN_FROM_PACKAGE..."
            az functionapp config appsettings delete \
              --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
              --resource-group rg-infrastructure-as-code \
              --setting-names WEBSITE_RUN_FROM_PACKAGE \
              --output none || echo "⚠️  Failed to remove WEBSITE_RUN_FROM_PACKAGE"
            echo "✅ WEBSITE_RUN_FROM_PACKAGE removed"
            sleep 5
          fi
          
          if [ -n "$USE_ZIP" ] && [ "$USE_ZIP" != "null" ] && [ "$USE_ZIP" != "" ]; then
            echo "⚠️  WEBSITE_USE_ZIP is set, removing it..."
            az functionapp config appsettings delete \
              --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
              --resource-group rg-infrastructure-as-code \
              --setting-names WEBSITE_USE_ZIP \
              --output none || echo "⚠️  Failed to remove WEBSITE_USE_ZIP"
            echo "✅ WEBSITE_USE_ZIP removed"
            sleep 5
          fi
          
          if [ -z "$RUN_FROM_PACKAGE" ] && [ -z "$USE_ZIP" ]; then
            echo "✅ No blocking app settings found"
          fi
          
          # Check Function App status before deployment
          echo "Checking Function App status..."
          az functionapp show \
            --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
            --resource-group rg-infrastructure-as-code \
            --query "{State:state, DefaultHostName:defaultHostName, Kind:kind}" \
            --output table || echo "⚠️  Could not get Function App status"
          
          # Deploy via Azure CLI
          echo "Starting deployment via Azure CLI..."
          
          # Get more details about the Function App before deployment
          echo "Getting detailed Function App information..."
          az functionapp show \
            --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
            --resource-group rg-infrastructure-as-code \
            --output json > /tmp/function-app-info.json 2>&1 || echo "⚠️  Could not get Function App details"
          
          echo "Function App details:"
          cat /tmp/function-app-info.json | jq '{name, state, defaultHostName, kind, httpsOnly, enabled, siteConfig}' 2>/dev/null || cat /tmp/function-app-info.json
          
          # List all app settings for debugging
          echo ""
          echo "Current app settings (first 20):"
          az functionapp config appsettings list \
            --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
            --resource-group rg-infrastructure-as-code \
            --output table 2>&1 | head -25 || echo "⚠️  Could not list app settings"
          
          # Use functionapp deployment (Function Apps are different from regular Web Apps)
          # Note: az webapp deployment was removed - Function Apps should use az functionapp deployment
          echo ""
          echo "Attempting deployment with verbose output..."
          DEPLOY_OUTPUT=$(az functionapp deployment source config-zip \
            --resource-group rg-infrastructure-as-code \
            --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
            --src "$ZIP_PATH" \
            --timeout 600 \
            --output json \
            --verbose 2>&1) || {
              echo "⚠️  Function App deployment failed, trying Kudu API with longer wait..."
              echo ""
              echo "=== Azure CLI Error Details ==="
              echo "Full error output:"
              echo "$DEPLOY_OUTPUT"
              echo ""
              
              # Try to extract more details from the error
              if echo "$DEPLOY_OUTPUT" | grep -q "Bad Request"; then
                echo "=== Bad Request Details ==="
                echo "This usually means:"
                echo "1. Invalid ZIP file format or structure"
                echo "2. Missing required files (host.json, functions.metadata)"
                echo "3. Function App configuration issue"
                echo "4. WEBSITE_RUN_FROM_PACKAGE or WEBSITE_USE_ZIP still set"
                echo ""
                
                # Check if settings were actually removed
                echo "Verifying settings removal..."
                FINAL_CHECK=$(az functionapp config appsettings list \
                  --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
                  --resource-group rg-infrastructure-as-code \
                  --query "[?name=='WEBSITE_RUN_FROM_PACKAGE' || name=='WEBSITE_USE_ZIP']" \
                  --output json 2>/dev/null || echo "[]")
                
                BLOCKING_SETTINGS=$(echo "$FINAL_CHECK" | jq -r '.[] | select(.value != null and .value != "") | .name' 2>/dev/null || echo "")
                
                if [ -n "$BLOCKING_SETTINGS" ]; then
                  echo "❌ ERROR: Blocking settings still present!"
                  echo "$BLOCKING_SETTINGS"
                  echo "This is likely the cause of the Bad Request error!"
                else
                  echo "✅ No blocking settings found"
                fi
                
                # Check ZIP file details
                echo ""
                echo "=== ZIP File Details ==="
                echo "ZIP file size: $(du -h "$ZIP_PATH" | cut -f1)"
                echo "ZIP file exists: $([ -f "$ZIP_PATH" ] && echo "YES" || echo "NO")"
                echo "ZIP file readable: $([ -r "$ZIP_PATH" ] && echo "YES" || echo "NO")"
                echo ""
                echo "First 10 files in ZIP:"
                unzip -l "$ZIP_PATH" 2>/dev/null | head -15 || echo "Could not list ZIP contents"
              fi
              
              echo ""
              echo "=== Attempting Kudu API Deployment ==="
              
                    # Wait additional time for deployment to process
                    echo "Waiting additional 60 seconds for deployment to process..."
                    sleep 60
              
              # Try Kudu API with sync deployment (not async)
              echo "Extracting credentials from publish profile for Kudu API..."
              PUBLISH_CREDS=$(az functionapp deployment list-publishing-credentials \
                --resource-group rg-infrastructure-as-code \
                --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
                --query "{username:publishingUserName, password:publishingPassword}" \
                --output json 2>/dev/null || echo "")
              
              if [ -z "$PUBLISH_CREDS" ]; then
                echo "❌ Could not get publishing credentials"
                exit 1
              fi
              
              USERNAME=$(echo "$PUBLISH_CREDS" | jq -r '.username' || echo "")
              PASSWORD=$(echo "$PUBLISH_CREDS" | jq -r '.password' || echo "")
              
              if [ -z "$USERNAME" ] || [ -z "$PASSWORD" ]; then
                echo "❌ Could not extract credentials for Kudu API"
                exit 1
              fi
              
              echo "Deploying via Kudu API (sync mode)..."
              AUTH=$(echo -n "${USERNAME}:${PASSWORD}" | base64 -w 0)
              # Use sync deployment (no isAsync) - this might work better
              KUDU_URL="https://${{ env.AZURE_FUNCTIONAPP_NAME }}.scm.azurewebsites.net/api/zipdeploy"
              
              HTTP_CODE=$(curl -s -o /tmp/kudu-response.txt -w "%{http_code}" \
                -X POST \
                -H "Authorization: Basic ${AUTH}" \
                -H "Content-Type: application/zip" \
                --data-binary @"${ZIP_PATH}" \
                "${KUDU_URL}")
              
              if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
                echo "✅ Deployment accepted via Kudu API (HTTP $HTTP_CODE)"
                cat /tmp/kudu-response.txt
                
                # Wait a moment for deployment to process
                echo "Waiting 10 seconds for deployment to process..."
                sleep 10
                
                # Get the latest deployment ID from response (fail-safe)
                DEPLOYMENT_ID=""
                RESPONSE_CONTENT=$(cat /tmp/kudu-response.txt 2>/dev/null || echo "")
                
                if [ -n "$RESPONSE_CONTENT" ]; then
                  # Try to extract ID from JSON response
                  DEPLOYMENT_ID=$(echo "$RESPONSE_CONTENT" | jq -r '.id // empty' 2>/dev/null || echo "")
                  
                  # If ID is null or empty, try to get latest deployment from deployments list
                  if [ -z "$DEPLOYMENT_ID" ] || [ "$DEPLOYMENT_ID" = "null" ]; then
                    echo "Deployment ID not in response, fetching latest deployment..."
                    LATEST_DEPLOYMENT=$(curl -s -H "Authorization: Basic ${AUTH}" \
                      "https://${{ env.AZURE_FUNCTIONAPP_NAME }}.scm.azurewebsites.net/api/deployments?top=1" 2>/dev/null || echo "[]")
                    
                    if [ -n "$LATEST_DEPLOYMENT" ] && [ "$LATEST_DEPLOYMENT" != "[]" ]; then
                      DEPLOYMENT_ID=$(echo "$LATEST_DEPLOYMENT" | jq -r '.[0].id // empty' 2>/dev/null || echo "")
                    fi
                  fi
                fi
                
                # Only try to get logs if we have a valid deployment ID
                if [ -n "$DEPLOYMENT_ID" ] && [ "$DEPLOYMENT_ID" != "null" ] && [ "$DEPLOYMENT_ID" != "" ]; then
                  echo "Checking deployment logs for ID: $DEPLOYMENT_ID"
                  
                  # Try to get deployment logs (fail-safe - don't fail if logs unavailable)
                  DEPLOYMENT_LOG=$(curl -s -H "Authorization: Basic ${AUTH}" \
                    "https://${{ env.AZURE_FUNCTIONAPP_NAME }}.scm.azurewebsites.net/api/deployments/$DEPLOYMENT_ID/log" 2>/dev/null || echo "")
                  
                  if [ -n "$DEPLOYMENT_LOG" ] && [ "$DEPLOYMENT_LOG" != "null" ]; then
                    echo "Deployment log:"
                    echo "$DEPLOYMENT_LOG" | head -100
                  else
                    echo "⚠️  Deployment logs not available (this is OK - deployment may still be processing)"
                  fi
                  
                  # Check deployment status (fail-safe)
                  DEPLOYMENT_STATUS=$(curl -s -H "Authorization: Basic ${AUTH}" \
                    "https://${{ env.AZURE_FUNCTIONAPP_NAME }}.scm.azurewebsites.net/api/deployments/$DEPLOYMENT_ID" 2>/dev/null | jq -r '.status // empty' || echo "")
                  
                  if [ "$DEPLOYMENT_STATUS" = "4" ]; then
                    echo "❌ Deployment failed (status: 4)"
                    exit 1
                  elif [ "$DEPLOYMENT_STATUS" = "3" ]; then
                    echo "⚠️  Deployment completed but may have errors (status: 3)"
                    echo "Checking if files were deployed..."
                  elif [ -n "$DEPLOYMENT_STATUS" ]; then
                    echo "✅ Deployment status: $DEPLOYMENT_STATUS"
                  else
                    echo "⚠️  Could not determine deployment status (deployment may still be processing)"
                  fi
                else
                  echo "⚠️  Could not determine deployment ID (deployment may still be processing)"
                  echo "This is OK - deployment was accepted (HTTP $HTTP_CODE)"
                fi
                
                DEPLOY_OUTPUT="Deployed via Kudu API"
              else
                echo "❌ Kudu API deployment failed (HTTP $HTTP_CODE)"
                cat /tmp/kudu-response.txt
                echo ""
                echo "Trying to get more details about the error..."
                
                # Try to get latest deployment (fail-safe)
                LATEST_DEPLOYMENT=$(curl -s -H "Authorization: Basic ${AUTH}" \
                  "https://${{ env.AZURE_FUNCTIONAPP_NAME }}.scm.azurewebsites.net/api/deployments?top=1" \
                  2>/dev/null | jq '.[0] // empty' 2>/dev/null || echo "")
                
                if [ -n "$LATEST_DEPLOYMENT" ] && [ "$LATEST_DEPLOYMENT" != "null" ] && [ "$LATEST_DEPLOYMENT" != "[]" ] && [ "$LATEST_DEPLOYMENT" != "" ]; then
                  echo "Latest deployment:"
                  echo "$LATEST_DEPLOYMENT" | jq '.' 2>/dev/null || echo "$LATEST_DEPLOYMENT"
                  
                  DEPLOYMENT_ID=$(echo "$LATEST_DEPLOYMENT" | jq -r '.id // empty' 2>/dev/null || echo "")
                  
                  # Only try to get logs if we have a valid, non-null deployment ID
                  if [ -n "$DEPLOYMENT_ID" ] && [ "$DEPLOYMENT_ID" != "null" ] && [ "$DEPLOYMENT_ID" != "" ]; then
                    echo ""
                    echo "Deployment log URL:"
                    echo "https://${{ env.AZURE_FUNCTIONAPP_NAME }}.scm.azurewebsites.net/api/deployments/$DEPLOYMENT_ID/log"
                    
                    # Try to get logs (fail-safe - don't fail if logs unavailable)
                    DEPLOYMENT_LOG=$(curl -s -H "Authorization: Basic ${AUTH}" \
                      "https://${{ env.AZURE_FUNCTIONAPP_NAME }}.scm.azurewebsites.net/api/deployments/$DEPLOYMENT_ID/log" \
                      2>/dev/null || echo "")
                    
                    if [ -n "$DEPLOYMENT_LOG" ] && [ "$DEPLOYMENT_LOG" != "null" ] && [ "$DEPLOYMENT_LOG" != "" ]; then
                      # Check if response is an error JSON
                      ERROR_CLASS=$(echo "$DEPLOYMENT_LOG" | jq -r '.ClassName // empty' 2>/dev/null || echo "")
                      if [ -z "$ERROR_CLASS" ] || [ "$ERROR_CLASS" = "null" ]; then
                        echo ""
                        echo "Deployment log content:"
                        echo "$DEPLOYMENT_LOG" | head -200
                      else
                        echo ""
                        echo "⚠️  Deployment log not available: $(echo "$DEPLOYMENT_LOG" | jq -r '.Message // "Unknown error"' 2>/dev/null || echo "Unknown")"
                      fi
                    else
                      echo ""
                      echo "⚠️  Deployment logs not available (this may be normal)"
                    fi
                  else
                    echo ""
                    echo "⚠️  Could not extract valid deployment ID from response"
                  fi
                else
                  echo ""
                  echo "⚠️  Could not retrieve deployment information"
                fi
                exit 1
              fi
            }
          }
          
          if [ "$DEPLOY_OUTPUT" != "Deployed via Kudu API" ]; then
            echo "✅ Deployment successful via Azure CLI!"
            echo "Deployment output:"
            echo "$DEPLOY_OUTPUT" | jq '.' 2>/dev/null || echo "$DEPLOY_OUTPUT"
          fi
          
          echo "Waiting 90 seconds for deployment to complete and Functions to register..."
          sleep 90
          
          # CRITICAL: Verify files were actually deployed
          echo "Verifying deployment by checking if files exist..."
          PUBLISH_CREDS=$(az functionapp deployment list-publishing-credentials \
            --resource-group rg-infrastructure-as-code \
            --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
            --query "{username:publishingUserName, password:publishingPassword}" \
            --output json 2>/dev/null || echo "")
          
          if [ -n "$PUBLISH_CREDS" ]; then
            USERNAME=$(echo "$PUBLISH_CREDS" | jq -r '.username' || echo "")
            PASSWORD=$(echo "$PUBLISH_CREDS" | jq -r '.password' || echo "")
            
            if [ -n "$USERNAME" ] && [ -n "$PASSWORD" ]; then
              AUTH=$(echo -n "${USERNAME}:${PASSWORD}" | base64 -w 0)
              
              # Check if host.json exists
              HTTP_CODE=$(curl -s -o /tmp/host-check.txt -w "%{http_code}" \
                -H "Authorization: Basic ${AUTH}" \
                "https://${{ env.AZURE_FUNCTIONAPP_NAME }}.scm.azurewebsites.net/api/vfs/site/wwwroot/host.json")
              
              if [ "$HTTP_CODE" = "200" ]; then
                echo "✅ Verified: host.json exists in deployment"
              else
                echo "❌ ERROR: host.json not found after deployment (HTTP $HTTP_CODE)"
                echo "Deployment may have failed silently!"
                exit 1
              fi
              
              # Check if ProcessCsvBlobTrigger.dll exists
              HTTP_CODE=$(curl -s -o /tmp/dll-check.txt -w "%{http_code}" \
                -H "Authorization: Basic ${AUTH}" \
                "https://${{ env.AZURE_FUNCTIONAPP_NAME }}.scm.azurewebsites.net/api/vfs/site/wwwroot/ProcessCsvBlobTrigger.dll")
              
              if [ "$HTTP_CODE" = "200" ]; then
                echo "✅ Verified: ProcessCsvBlobTrigger.dll exists in deployment"
              else
                echo "⚠️  WARNING: ProcessCsvBlobTrigger.dll not found (HTTP $HTTP_CODE)"
                echo "This might be OK if DLLs are in a subdirectory"
              fi
            fi
          fi
          
          # Verify deployment by checking Function App status
          echo "Verifying Function App status..."
          az functionapp show \
            --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
            --resource-group rg-infrastructure-as-code \
            --query "{State:state, DefaultHostName:defaultHostName}" \
            --output table || echo "⚠️  Could not verify Function App status"

      - name: 'Verify deployment'
        shell: bash
        run: |
          echo "Function App deployed successfully!"
          echo "Function App Name: ${{ env.AZURE_FUNCTIONAPP_NAME }}"
          echo "Waiting 30 seconds for Functions to be registered..."
          sleep 30
          echo "Deployment completed at $(date)"
          
      - name: 'List deployed functions'
        shell: bash
        run: |
          echo "Checking deployed functions..."
          az functionapp function list \
            --name ${{ env.AZURE_FUNCTIONAPP_NAME }} \
            --resource-group rg-infrastructure-as-code \
            --output table || echo "Functions not yet visible (may take a few minutes)"


