name: Deploy Azure Functions

on:
  push:
    branches:
      - main
    paths:
      - 'azure-functions/**'
  workflow_dispatch:

env:
  AZURE_FUNCTIONAPP_NAME: 'func-integration-main' # Integration platform Function App
  AZURE_FUNCTIONAPP_PACKAGE_PATH: 'azure-functions/main'
  DOTNET_VERSION: '8.0.x'

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Restore dependencies
        run: |
          cd ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}
          dotnet restore
        continue-on-error: false

      - name: Build and Publish
        run: |
          cd ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}
          # Build and publish in one step with --no-self-contained to ensure smaller package size
          dotnet publish --no-self-contained --configuration Release --output ./publish
        continue-on-error: false

      - name: Install Azure Functions Core Tools
        run: |
          echo "Installing Azure Functions Core Tools..."
          curl https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor > microsoft.gpg
          sudo mv microsoft.gpg /etc/apt/trusted.gpg.d/microsoft.gpg
          sudo sh -c 'echo "deb [arch=amd64] https://packages.microsoft.com/repos/microsoft-ubuntu-$(lsb_release -cs)-prod $(lsb_release -cs) main" > /etc/apt/sources.list.d/dotnetdev.list'
          sudo apt-get update
          sudo apt-get install -y azure-functions-core-tools-4
          func --version
        continue-on-error: false

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Verify Function App exists
        run: |
          set -e  # Exit on error
          set -x  # Print commands for debugging
          
          echo "=========================================="
          echo "Verifying Function App exists..."
          echo "=========================================="
          echo ""
          echo "Resource Group: ${{ secrets.AZURE_RESOURCE_GROUP }}"
          echo "Function App Name: ${{ secrets.AZURE_FUNCTIONAPP_NAME }}"
          echo ""
          
          # Check if secrets are set
          if [ -z "${{ secrets.AZURE_RESOURCE_GROUP }}" ]; then
            echo "❌ ERROR: AZURE_RESOURCE_GROUP secret is not set!"
            echo "Please configure this secret in GitHub repository settings."
            echo "Go to: Settings > Secrets and variables > Actions"
            exit 1
          fi
          
          if [ -z "${{ secrets.AZURE_FUNCTIONAPP_NAME }}" ]; then
            echo "❌ ERROR: AZURE_FUNCTIONAPP_NAME secret is not set!"
            echo "Please configure this secret in GitHub repository settings."
            echo "Go to: Settings > Secrets and variables > Actions"
            exit 1
          fi
          
          # Check Azure login status
          echo "Step 1: Checking Azure authentication..."
          AZ_ACCOUNT_OUTPUT=$(az account show 2>&1) || {
            AZ_ACCOUNT_EXIT_CODE=$?
            echo "❌ ERROR: Azure authentication failed!"
            echo ""
            echo "Exit Code: $AZ_ACCOUNT_EXIT_CODE"
            echo "Error Output:"
            echo "$AZ_ACCOUNT_OUTPUT"
            echo ""
            echo "Troubleshooting:"
            echo "1. Verify AZURE_CREDENTIALS secret is set correctly"
            echo "2. Check if service principal has expired"
            echo "3. Verify service principal has Contributor role"
            echo "4. Check service principal: az ad sp list --display-name <sp-name>"
            exit 1
          }
          SUBSCRIPTION_ID=$(az account show --query id -o tsv 2>/dev/null || echo "Could not get")
          SUBSCRIPTION_NAME=$(az account show --query name -o tsv 2>/dev/null || echo "Could not get")
          echo "✅ Azure authentication verified"
          echo "  Subscription ID: $SUBSCRIPTION_ID"
          echo "  Subscription Name: $SUBSCRIPTION_NAME"
          echo ""
          
          # Check resource group
          echo "=========================================="
          echo "Step 2: Checking resource group..."
          echo "=========================================="
          RG_OUTPUT=$(az group show \
            --name "${{ secrets.AZURE_RESOURCE_GROUP }}" \
            --query "{Name: name, Location: location, ProvisioningState: properties.provisioningState}" \
            --output table 2>&1) || {
            RG_EXIT_CODE=$?
            echo "❌ ERROR: Resource group check failed!"
            echo ""
            echo "Exit Code: $RG_EXIT_CODE"
            echo "Error Output:"
            echo "$RG_OUTPUT"
            echo ""
            echo "Detailed Information:"
            echo "  Resource Group Name: '${{ secrets.AZURE_RESOURCE_GROUP }}'"
            echo "  Subscription ID: $SUBSCRIPTION_ID"
            echo ""
            echo "Available resource groups in subscription:"
            az group list \
              --query "[].{Name: name, Location: location, ProvisioningState: properties.provisioningState}" \
              --output table 2>&1 || {
              echo "  Could not list resource groups. Error:"
              echo "  $(az group list 2>&1)"
            }
            echo ""
            echo "Troubleshooting steps:"
            echo "1. Verify the resource group name in GitHub secrets (AZURE_RESOURCE_GROUP)"
            echo "   Current value: '${{ secrets.AZURE_RESOURCE_GROUP }}'"
            echo "2. Check if you have access to the subscription"
            echo "3. Verify Azure credentials are correct"
            echo "4. Check if resource group exists: az group show --name '${{ secrets.AZURE_RESOURCE_GROUP }}'"
            echo "5. List all resource groups: az group list"
            echo ""
            echo "Common Error Codes:"
            echo "  Exit Code 3: Resource not found or access denied"
            echo "  Exit Code 1: General error (check error output above)"
            echo "  Exit Code 2: Invalid arguments or configuration"
            exit 1
          }
          echo "✅ Resource group exists:"
          echo "$RG_OUTPUT"
          echo ""
          
          # Check Function App
          echo "=========================================="
          echo "Step 3: Checking Function App..."
          echo "=========================================="
          echo "Running: az functionapp show --resource-group \"${{ secrets.AZURE_RESOURCE_GROUP }}\" --name \"${{ secrets.AZURE_FUNCTIONAPP_NAME }}\""
          FUNCTION_APP_OUTPUT=$(az functionapp show \
            --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}" \
            --name "${{ secrets.AZURE_FUNCTIONAPP_NAME }}" \
            --query "{Name: name, State: state, Runtime: siteConfig.linuxFxVersion, Location: location, DefaultHostName: defaultHostName}" \
            --output table 2>&1)
          EXIT_CODE=$?
          
          if [ $EXIT_CODE -ne 0 ]; then
            echo "❌ ERROR: Function App check failed!"
            echo ""
            echo "Exit Code: $EXIT_CODE"
            echo ""
            echo "Full Error Output:"
            echo "----------------------------------------"
            echo "$FUNCTION_APP_OUTPUT"
            echo "----------------------------------------"
            echo ""
            echo "Detailed Error Information:"
            echo "  Resource Group: '${{ secrets.AZURE_RESOURCE_GROUP }}'"
            echo "  Function App Name: '${{ secrets.AZURE_FUNCTIONAPP_NAME }}'"
            echo "  Subscription ID: $SUBSCRIPTION_ID"
            echo ""
            echo "Attempting to list Function Apps in resource group '${{ secrets.AZURE_RESOURCE_GROUP }}'..."
            FUNCTION_APP_LIST_OUTPUT=$(az functionapp list \
              --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}" \
              --query "[].{Name: name, State: state, Runtime: siteConfig.linuxFxVersion, Location: location}" \
              --output table 2>&1)
            FUNCTION_APP_LIST_EXIT=$?
            
            if [ $FUNCTION_APP_LIST_EXIT -eq 0 ] && [ -n "$FUNCTION_APP_LIST_OUTPUT" ] && [ "$FUNCTION_APP_LIST_OUTPUT" != "[]" ]; then
              echo "Available Function Apps in resource group:"
              echo "$FUNCTION_APP_LIST_OUTPUT"
            else
              echo "  Could not list Function Apps in resource group."
              if [ $FUNCTION_APP_LIST_EXIT -ne 0 ]; then
                echo "  List command exit code: $FUNCTION_APP_LIST_EXIT"
                echo "  List command error:"
                echo "  $FUNCTION_APP_LIST_OUTPUT"
              else
                echo "  No Function Apps found in this resource group"
              fi
            fi
            echo ""
            echo "Attempting to list all Function Apps in subscription..."
            ALL_FUNCTION_APPS=$(az functionapp list \
              --query "[].{Name: name, ResourceGroup: resourceGroup, State: state, Location: location}" \
              --output table 2>&1)
            ALL_FUNCTION_APPS_EXIT=$?
            if [ $ALL_FUNCTION_APPS_EXIT -eq 0 ]; then
              echo "$ALL_FUNCTION_APPS"
            else
              echo "  Could not list all Function Apps. Exit code: $ALL_FUNCTION_APPS_EXIT"
              echo "  Error: $ALL_FUNCTION_APPS"
            fi
            echo ""
            echo "=========================================="
            echo "Troubleshooting Information"
            echo "=========================================="
            echo ""
            echo "1. Verify the Function App name in GitHub secrets (AZURE_FUNCTIONAPP_NAME)"
            echo "   Current value: '${{ secrets.AZURE_FUNCTIONAPP_NAME }}'"
            echo ""
            echo "2. Verify the resource group name in GitHub secrets (AZURE_RESOURCE_GROUP)"
            echo "   Current value: '${{ secrets.AZURE_RESOURCE_GROUP }}'"
            echo ""
            echo "3. Check if the Function App was created via Terraform/Bicep deployment"
            echo ""
            echo "4. If using Bicep, ensure 'enableFunctionApp' parameter is set to true"
            echo ""
            echo "5. Manual verification commands:"
            echo "   az functionapp show --resource-group '${{ secrets.AZURE_RESOURCE_GROUP }}' --name '${{ secrets.AZURE_FUNCTIONAPP_NAME }}'"
            echo "   az functionapp list --resource-group '${{ secrets.AZURE_RESOURCE_GROUP }}'"
            echo ""
            echo "Common Error Codes:"
            echo "  Exit Code 3: Resource not found or access denied"
            echo "  Exit Code 1: General error (check error output above)"
            echo "  Exit Code 2: Invalid arguments or configuration"
            echo ""
            echo "Azure CLI Error Reference:"
            echo "  https://docs.microsoft.com/cli/azure/functionapp#az-functionapp-show"
            echo ""
            echo "=========================================="
            exit 1
          }
          
          echo "✅ Function App found:"
          echo "$FUNCTION_APP_OUTPUT"
          echo ""
          
          # Get Function App URL
          FUNCTION_APP_URL=$(az functionapp show \
            --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}" \
            --name "${{ secrets.AZURE_FUNCTIONAPP_NAME }}" \
            --query defaultHostName -o tsv 2>&1) || {
            echo "⚠️  Warning: Could not get Function App URL"
            echo "Error: $FUNCTION_APP_URL"
          }
          
          if [ -n "$FUNCTION_APP_URL" ] && [ "$FUNCTION_APP_URL" != "null" ]; then
            echo "Function App URL: https://$FUNCTION_APP_URL"
          fi
          echo ""
          echo "=========================================="
          echo "✅ Verification completed successfully"
          echo "=========================================="
        continue-on-error: false

      - name: Deploy to Azure Functions using func publish
        run: |
          echo "Deploying using func azure functionapp publish --dotnet-isolated..."
          cd ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}
          
          # Check publish folder size before deployment
          echo "Checking publish folder size..."
          du -sh ./publish || echo "Could not check size"
          echo ""
          echo "Publish folder contents (first 10 items):"
          ls -lh ./publish | head -10 || echo "Could not list contents"
          echo ""
          
          # Use func publish command with explicit path to pre-built publish folder
          # The --dotnet-isolated flag ensures it uses the correct runtime
          # IMPORTANT: func publish will use the existing ./publish folder if it exists,
          # but we need to ensure it doesn't rebuild. The --dotnet-isolated flag should
          # use the pre-built folder, but if it rebuilds, it might not use --no-self-contained.
          # By pre-building with --no-self-contained above, we ensure the package is small.
          func azure functionapp publish ${{ secrets.AZURE_FUNCTIONAPP_NAME }} --dotnet-isolated --force
          
          echo ""
          echo "✅ Deployment completed successfully!"
        continue-on-error: false
      

      - name: Set Required App Settings
        run: |
          echo "Setting required app settings..."
          
          # Verify WEBSITE_RUN_FROM_PACKAGE is set
          PACKAGE_URL=$(az functionapp config appsettings list \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --name ${{ secrets.AZURE_FUNCTIONAPP_NAME }} \
            --query "[?name=='WEBSITE_RUN_FROM_PACKAGE'].value" \
            -o tsv)
          
          if [ -z "$PACKAGE_URL" ] || [ "$PACKAGE_URL" == "None" ] || [ "$PACKAGE_URL" == "" ]; then
            echo "ERROR: WEBSITE_RUN_FROM_PACKAGE is not set!"
            exit 1
          else
            echo "✅ WEBSITE_RUN_FROM_PACKAGE is set: ${PACKAGE_URL:0:80}..."
          fi
          
          # Disable placeholder mode to ensure functions are loaded
          echo "Disabling placeholder mode..."
          az functionapp config appsettings set \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --name ${{ secrets.AZURE_FUNCTIONAPP_NAME }} \
            --settings WEBSITE_USE_PLACEHOLDER="0" \
            --output none
          
          echo "✅ App settings configured"
        continue-on-error: false
      
      - name: Restart Function App
        run: |
          echo "Restarting Function App to load new deployment..."
          az functionapp restart \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --name ${{ secrets.AZURE_FUNCTIONAPP_NAME }}
          
          echo "Waiting for Function App to be ready..."
          sleep 45
          
          # Check Function App state
          STATE=$(az functionapp show \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --name ${{ secrets.AZURE_FUNCTIONAPP_NAME }} \
            --query "state" \
            -o tsv)
          
          echo "Function App state: $STATE"
        continue-on-error: false

      - name: Sync Function Triggers
        run: |
          echo "Synchronizing function triggers (required for Linux Consumption Plan)..."
          
          # Trigger sync by calling the admin API (this forces Azure to discover functions)
          MASTER_KEY=$(az functionapp keys list \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --name ${{ secrets.AZURE_FUNCTIONAPP_NAME }} \
            --query "masterKey" \
            -o tsv)
          
          if [ -z "$MASTER_KEY" ] || [ "$MASTER_KEY" == "None" ]; then
            echo "⚠ Could not retrieve master key, skipping API sync"
          else
            # Call admin API to sync triggers
            echo "Calling sync triggers API..."
            curl -X POST \
              "https://${{ secrets.AZURE_FUNCTIONAPP_NAME }}.azurewebsites.net/admin/host/synctriggers" \
              -H "x-functions-key: $MASTER_KEY" \
              -H "Content-Type: application/json" \
              --max-time 30 \
              --fail-with-body || echo "⚠ Sync triggers API call failed (this is OK if functions are not yet discovered)"
          fi
          
          # Wait a bit more for sync to complete
          sleep 15
        continue-on-error: false

      - name: Check Function App Logs
        run: |
          echo "=== Checking Function App Logs ==="
          echo "Getting recent logs (this may take a moment)..."
          
          # Enable logging if not already enabled
          az webapp log config \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --name ${{ secrets.AZURE_FUNCTIONAPP_NAME }} \
            --application-logging filesystem \
            --detailed-error-messages true \
            --failed-request-tracing true \
            --web-server-logging filesystem \
            --output none || true
          
          # Get logs from log stream (last 100 lines)
          echo "Recent log entries:"
          timeout 30 az webapp log tail \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --name ${{ secrets.AZURE_FUNCTIONAPP_NAME }} \
            --filter Error,Warning || echo "Could not retrieve logs (this is OK)"
        continue-on-error: true

      - name: Verify Functions are loaded
        run: |
          echo "Checking if functions are loaded..."
          
          # Try multiple times as functions may take time to appear
          MAX_RETRIES=6
          RETRY_COUNT=0
          FUNCTIONS_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            FUNCTIONS_COUNT=$(az functionapp function list \
              --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
              --name ${{ secrets.AZURE_FUNCTIONAPP_NAME }} \
              --query "length(@)" \
              -o tsv 2>/dev/null || echo "0")
            
            if [ "$FUNCTIONS_COUNT" -gt "0" ]; then
              echo "✅ Found $FUNCTIONS_COUNT function(s)!"
              az functionapp function list \
                --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
                --name ${{ secrets.AZURE_FUNCTIONAPP_NAME }} \
                --query "[].{Name: name, Status: invokeUrlTemplate}" \
                --output table
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "Attempt $RETRY_COUNT/$MAX_RETRIES: No functions found yet, waiting..."
              sleep 15
            fi
          done
          
          if [ "$FUNCTIONS_COUNT" -eq "0" ]; then
            echo "⚠ WARNING: No functions found after $MAX_RETRIES attempts"
            echo ""
            echo "Diagnostic information:"
            echo "1. Function App state:"
            az functionapp show \
              --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
              --name ${{ secrets.AZURE_FUNCTIONAPP_NAME }} \
              --query "{name: name, state: state, kind: kind}" \
              --output table
            echo ""
            echo "2. App Settings:"
            az functionapp config appsettings list \
              --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
              --name ${{ secrets.AZURE_FUNCTIONAPP_NAME }} \
              --query "[?name=='FUNCTIONS_WORKER_RUNTIME' || name=='WEBSITE_RUN_FROM_PACKAGE' || name=='WEBSITE_USE_PLACEHOLDER'].{Name: name, Value: value}" \
              --output table
            echo ""
            echo "Please check:"
            echo "- Function App logs in Azure Portal (Log stream)"
            echo "- WEBSITE_RUN_FROM_PACKAGE is set correctly"
            echo "- Function App is running (not stopped)"
            echo "- Run the diagnose-functions.yml workflow for more details"
          fi
        continue-on-error: false
      
      - name: Health Check After Deployment
        run: |
          echo "Waiting for Function App to be ready..."
          sleep 30
          
          MAX_RETRIES=5
          RETRY_COUNT=0
          HEALTH_CHECK_URL="https://${{ secrets.AZURE_FUNCTIONAPP_NAME }}.azurewebsites.net/api/health"
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            HEALTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$HEALTH_CHECK_URL" || echo "000")
            
            if [ "$HEALTH_STATUS" = "200" ]; then
              echo "✅ Health check passed!"
              echo "Health check response:"
              curl -s "$HEALTH_CHECK_URL" | jq '.' || curl -s "$HEALTH_CHECK_URL"
              exit 0
            fi
            
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "Health check attempt $RETRY_COUNT/$MAX_RETRIES failed (HTTP $HEALTH_STATUS), retrying..."
            sleep 10
          done
          
          echo "❌ Health check failed after $MAX_RETRIES attempts"
          echo "Last health check response:"
          curl -s "$HEALTH_CHECK_URL" || echo "Could not reach health endpoint"
          exit 1
        continue-on-error: false

      - name: Verify deployment
        run: |
          echo "✅ Deployment completed successfully!"
          echo "Function App: ${{ secrets.AZURE_FUNCTIONAPP_NAME }}"
          echo "Resource Group: ${{ secrets.AZURE_RESOURCE_GROUP }}"
          echo ""
          echo "Function App URL:"
          az functionapp show \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --name ${{ secrets.AZURE_FUNCTIONAPP_NAME }} \
            --query defaultHostName \
            --output tsv
          echo ""
          echo "Checking Function App status..."
          az functionapp show \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --name ${{ secrets.AZURE_FUNCTIONAPP_NAME }} \
            --query "{state: state, hostNames: defaultHostName}" \
            --output table
          echo ""
          echo "Checking WEBSITE_RUN_FROM_PACKAGE setting..."
          az functionapp config appsettings list \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --name ${{ secrets.AZURE_FUNCTIONAPP_NAME }} \
            --query "[?name=='WEBSITE_RUN_FROM_PACKAGE'].{Name: name, Value: value}" \
            --output table

      # Note: Required GitHub secrets:
      # 1. AZURE_CREDENTIALS: Service Principal credentials (JSON format)
      #    Create with: az ad sp create-for-rbac --name "github-actions" --role contributor --scopes /subscriptions/{subscription-id}/resourceGroups/{resource-group} --sdk-auth
      # 2. AZURE_RESOURCE_GROUP: Resource group name (e.g., "rg-interface-configuration")
      # 3. AZURE_FUNCTIONAPP_NAME: Function app name (get from terraform output function_app_name)
      #
      # This workflow uses func azure functionapp publish --dotnet-isolated to deploy,
      # which handles the deployment process automatically including setting WEBSITE_RUN_FROM_PACKAGE.
      #
      # IMPORTANT: The dotnet publish command MUST use --no-self-contained to create a framework-dependent deployment.
      # This ensures smaller package sizes (typically < 50MB vs > 200MB for self-contained) and faster deployments.
      # 
      # MEMORY: ALWAYS build with --no-self-contained flag for Azure Functions to ensure smaller packages and faster deployments.
      #
      # Key difference from local deployment:
      # - Local: `func azure functionapp publish` automatically builds with --no-self-contained
      # - GitHub Actions: We pre-build with --no-self-contained (line 38) to ensure the package is small,
      #   then func publish uses the pre-built ./publish folder. If func publish rebuilds, it might not
      #   use --no-self-contained, causing large packages and deployment failures.

