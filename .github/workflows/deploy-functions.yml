name: Deploy Azure Functions

on:
  push:
    branches:
      - main
    paths:
      - 'azure-functions/**'
  workflow_dispatch:

env:
  AZURE_FUNCTIONAPP_NAME: 'func-integration-main' # Integration platform Function App
  AZURE_FUNCTIONAPP_PACKAGE_PATH: 'azure-functions/main'
  DOTNET_VERSION: '8.0.x'

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Restore dependencies
        run: |
          cd ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}
          dotnet restore
        continue-on-error: false

      - name: Build
        run: |
          cd ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}
          dotnet build --configuration Release --no-restore
        continue-on-error: false

      - name: Publish
        run: |
          cd ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}
          dotnet publish --no-self-contained --configuration Release --output ./publish --no-build
        continue-on-error: false

      - name: Install Azure Functions Core Tools
        run: |
          echo "Installing Azure Functions Core Tools..."
          curl https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor > microsoft.gpg
          sudo mv microsoft.gpg /etc/apt/trusted.gpg.d/microsoft.gpg
          sudo sh -c 'echo "deb [arch=amd64] https://packages.microsoft.com/repos/microsoft-ubuntu-$(lsb_release -cs)-prod $(lsb_release -cs) main" > /etc/apt/sources.list.d/dotnetdev.list'
          sudo apt-get update
          sudo apt-get install -y azure-functions-core-tools-4
          func --version
        continue-on-error: false

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Verify Function App exists
        run: |
          echo "Verifying Function App exists..."
          echo "Resource Group: ${{ secrets.AZURE_RESOURCE_GROUP }}"
          echo "Function App Name: ${{ secrets.AZURE_FUNCTIONAPP_NAME }}"
          echo ""
          
          # Check if resource group exists
          echo "Checking resource group..."
          RG_EXISTS=$(az group show --name ${{ secrets.AZURE_RESOURCE_GROUP }} --query "name" -o tsv 2>&1)
          if [ $? -ne 0 ]; then
            echo "❌ ERROR: Resource group '${{ secrets.AZURE_RESOURCE_GROUP }}' not found!"
            echo ""
            echo "Available resource groups:"
            az group list --query "[].name" -o table || true
            exit 1
          fi
          echo "✅ Resource group exists: ${{ secrets.AZURE_RESOURCE_GROUP }}"
          echo ""
          
          # Try to get Function App details
          echo "Checking Function App..."
          FUNCTION_APP_OUTPUT=$(az functionapp show \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --name ${{ secrets.AZURE_FUNCTIONAPP_NAME }} \
            --query "{name: name, state: state, runtime: siteConfig.linuxFxVersion}" \
            --output table 2>&1)
          EXIT_CODE=$?
          
          if [ $EXIT_CODE -ne 0 ]; then
            echo "❌ ERROR: Function App '${{ secrets.AZURE_FUNCTIONAPP_NAME }}' not found!"
            echo ""
            echo "Azure Error Details:"
            echo "$FUNCTION_APP_OUTPUT"
            echo ""
            echo "Available Function Apps in resource group '${{ secrets.AZURE_RESOURCE_GROUP }}':"
            az functionapp list \
              --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
              --query "[].{Name: name, State: state, Runtime: siteConfig.linuxFxVersion}" \
              --output table || echo "No Function Apps found in this resource group"
            echo ""
            echo "Troubleshooting steps:"
            echo "1. Verify the Function App name in GitHub secrets (AZURE_FUNCTIONAPP_NAME)"
            echo "2. Verify the resource group name in GitHub secrets (AZURE_RESOURCE_GROUP)"
            echo "3. Check if the Function App was created via Terraform/Bicep deployment"
            echo "4. If using Bicep, ensure 'enableFunctionApp' parameter is set to true"
            echo "5. Run: az functionapp list --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }}"
            exit 1
          fi
          
          echo "✅ Function App found:"
          echo "$FUNCTION_APP_OUTPUT"
        continue-on-error: false

      - name: Deploy to Azure Functions using func publish
        run: |
          echo "Deploying using func azure functionapp publish --dotnet-isolated..."
          cd ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}
          
          # Use func publish command (this was the only way that worked)
          # func publish will use the published output from ./publish directory
          func azure functionapp publish ${{ secrets.AZURE_FUNCTIONAPP_NAME }} --dotnet-isolated --force
          
          echo ""
          echo "✅ Deployment completed successfully!"
        continue-on-error: false
      

      - name: Set Required App Settings
        run: |
          echo "Setting required app settings..."
          
          # Verify WEBSITE_RUN_FROM_PACKAGE is set
          PACKAGE_URL=$(az functionapp config appsettings list \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --name ${{ secrets.AZURE_FUNCTIONAPP_NAME }} \
            --query "[?name=='WEBSITE_RUN_FROM_PACKAGE'].value" \
            -o tsv)
          
          if [ -z "$PACKAGE_URL" ] || [ "$PACKAGE_URL" == "None" ] || [ "$PACKAGE_URL" == "" ]; then
            echo "ERROR: WEBSITE_RUN_FROM_PACKAGE is not set!"
            exit 1
          else
            echo "✅ WEBSITE_RUN_FROM_PACKAGE is set: ${PACKAGE_URL:0:80}..."
          fi
          
          # Disable placeholder mode to ensure functions are loaded
          echo "Disabling placeholder mode..."
          az functionapp config appsettings set \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --name ${{ secrets.AZURE_FUNCTIONAPP_NAME }} \
            --settings WEBSITE_USE_PLACEHOLDER="0" \
            --output none
          
          echo "✅ App settings configured"
        continue-on-error: false
      
      - name: Restart Function App
        run: |
          echo "Restarting Function App to load new deployment..."
          az functionapp restart \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --name ${{ secrets.AZURE_FUNCTIONAPP_NAME }}
          
          echo "Waiting for Function App to be ready..."
          sleep 45
          
          # Check Function App state
          STATE=$(az functionapp show \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --name ${{ secrets.AZURE_FUNCTIONAPP_NAME }} \
            --query "state" \
            -o tsv)
          
          echo "Function App state: $STATE"
        continue-on-error: false

      - name: Sync Function Triggers
        run: |
          echo "Synchronizing function triggers (required for Linux Consumption Plan)..."
          
          # Trigger sync by calling the admin API (this forces Azure to discover functions)
          MASTER_KEY=$(az functionapp keys list \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --name ${{ secrets.AZURE_FUNCTIONAPP_NAME }} \
            --query "masterKey" \
            -o tsv)
          
          if [ -z "$MASTER_KEY" ] || [ "$MASTER_KEY" == "None" ]; then
            echo "⚠ Could not retrieve master key, skipping API sync"
          else
            # Call admin API to sync triggers
            echo "Calling sync triggers API..."
            curl -X POST \
              "https://${{ secrets.AZURE_FUNCTIONAPP_NAME }}.azurewebsites.net/admin/host/synctriggers" \
              -H "x-functions-key: $MASTER_KEY" \
              -H "Content-Type: application/json" \
              --max-time 30 \
              --fail-with-body || echo "⚠ Sync triggers API call failed (this is OK if functions are not yet discovered)"
          fi
          
          # Wait a bit more for sync to complete
          sleep 15
        continue-on-error: false

      - name: Check Function App Logs
        run: |
          echo "=== Checking Function App Logs ==="
          echo "Getting recent logs (this may take a moment)..."
          
          # Enable logging if not already enabled
          az webapp log config \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --name ${{ secrets.AZURE_FUNCTIONAPP_NAME }} \
            --application-logging filesystem \
            --detailed-error-messages true \
            --failed-request-tracing true \
            --web-server-logging filesystem \
            --output none || true
          
          # Get logs from log stream (last 100 lines)
          echo "Recent log entries:"
          timeout 30 az webapp log tail \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --name ${{ secrets.AZURE_FUNCTIONAPP_NAME }} \
            --filter Error,Warning || echo "Could not retrieve logs (this is OK)"
        continue-on-error: true

      - name: Verify Functions are loaded
        run: |
          echo "Checking if functions are loaded..."
          
          # Try multiple times as functions may take time to appear
          MAX_RETRIES=6
          RETRY_COUNT=0
          FUNCTIONS_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            FUNCTIONS_COUNT=$(az functionapp function list \
              --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
              --name ${{ secrets.AZURE_FUNCTIONAPP_NAME }} \
              --query "length(@)" \
              -o tsv 2>/dev/null || echo "0")
            
            if [ "$FUNCTIONS_COUNT" -gt "0" ]; then
              echo "✅ Found $FUNCTIONS_COUNT function(s)!"
              az functionapp function list \
                --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
                --name ${{ secrets.AZURE_FUNCTIONAPP_NAME }} \
                --query "[].{Name: name, Status: invokeUrlTemplate}" \
                --output table
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "Attempt $RETRY_COUNT/$MAX_RETRIES: No functions found yet, waiting..."
              sleep 15
            fi
          done
          
          if [ "$FUNCTIONS_COUNT" -eq "0" ]; then
            echo "⚠ WARNING: No functions found after $MAX_RETRIES attempts"
            echo ""
            echo "Diagnostic information:"
            echo "1. Function App state:"
            az functionapp show \
              --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
              --name ${{ secrets.AZURE_FUNCTIONAPP_NAME }} \
              --query "{name: name, state: state, kind: kind}" \
              --output table
            echo ""
            echo "2. App Settings:"
            az functionapp config appsettings list \
              --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
              --name ${{ secrets.AZURE_FUNCTIONAPP_NAME }} \
              --query "[?name=='FUNCTIONS_WORKER_RUNTIME' || name=='WEBSITE_RUN_FROM_PACKAGE' || name=='WEBSITE_USE_PLACEHOLDER'].{Name: name, Value: value}" \
              --output table
            echo ""
            echo "Please check:"
            echo "- Function App logs in Azure Portal (Log stream)"
            echo "- WEBSITE_RUN_FROM_PACKAGE is set correctly"
            echo "- Function App is running (not stopped)"
            echo "- Run the diagnose-functions.yml workflow for more details"
          fi
        continue-on-error: false
      
      - name: Health Check After Deployment
        run: |
          echo "Waiting for Function App to be ready..."
          sleep 30
          
          MAX_RETRIES=5
          RETRY_COUNT=0
          HEALTH_CHECK_URL="https://${{ secrets.AZURE_FUNCTIONAPP_NAME }}.azurewebsites.net/api/health"
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            HEALTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$HEALTH_CHECK_URL" || echo "000")
            
            if [ "$HEALTH_STATUS" = "200" ]; then
              echo "✅ Health check passed!"
              echo "Health check response:"
              curl -s "$HEALTH_CHECK_URL" | jq '.' || curl -s "$HEALTH_CHECK_URL"
              exit 0
            fi
            
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "Health check attempt $RETRY_COUNT/$MAX_RETRIES failed (HTTP $HEALTH_STATUS), retrying..."
            sleep 10
          done
          
          echo "❌ Health check failed after $MAX_RETRIES attempts"
          echo "Last health check response:"
          curl -s "$HEALTH_CHECK_URL" || echo "Could not reach health endpoint"
          exit 1
        continue-on-error: false

      - name: Verify deployment
        run: |
          echo "✅ Deployment completed successfully!"
          echo "Function App: ${{ secrets.AZURE_FUNCTIONAPP_NAME }}"
          echo "Resource Group: ${{ secrets.AZURE_RESOURCE_GROUP }}"
          echo ""
          echo "Function App URL:"
          az functionapp show \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --name ${{ secrets.AZURE_FUNCTIONAPP_NAME }} \
            --query defaultHostName \
            --output tsv
          echo ""
          echo "Checking Function App status..."
          az functionapp show \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --name ${{ secrets.AZURE_FUNCTIONAPP_NAME }} \
            --query "{state: state, hostNames: defaultHostName}" \
            --output table
          echo ""
          echo "Checking WEBSITE_RUN_FROM_PACKAGE setting..."
          az functionapp config appsettings list \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --name ${{ secrets.AZURE_FUNCTIONAPP_NAME }} \
            --query "[?name=='WEBSITE_RUN_FROM_PACKAGE'].{Name: name, Value: value}" \
            --output table

      # Note: Required GitHub secrets:
      # 1. AZURE_CREDENTIALS: Service Principal credentials (JSON format)
      #    Create with: az ad sp create-for-rbac --name "github-actions" --role contributor --scopes /subscriptions/{subscription-id}/resourceGroups/{resource-group} --sdk-auth
      # 2. AZURE_RESOURCE_GROUP: Resource group name (e.g., "rg-interface-configuration")
      # 3. AZURE_FUNCTIONAPP_NAME: Function app name (get from terraform output function_app_name)
      #
      # This workflow uses func azure functionapp publish --dotnet-isolated to deploy,
      # which handles the deployment process automatically including setting WEBSITE_RUN_FROM_PACKAGE.
      # The dotnet publish command uses --no-self-contained to create a framework-dependent deployment.
      # MEMORY: ALWAYS build with --no-self-contained flag for Azure Functions to ensure smaller packages and faster deployments.

