# GitLab CI/CD Pipeline for Interface Configurator
# This pipeline builds, tests, and optionally deploys the application

# Workflow rules: Always run pipelines on push events (including from mirroring)
# This ensures pipelines run for all push events, including mirrored branches
# Note: GitLab mirroring may not trigger pipelines automatically - you may need to
# manually trigger or enable "Trigger pipelines for mirror updates" in mirror settings
workflow:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "push"'
    - if: '$CI_PIPELINE_SOURCE == "web"'
    - if: '$CI_PIPELINE_SOURCE == "api"'
    - if: '$CI_PIPELINE_SOURCE == "trigger"'
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
    - if: '$CI_PIPELINE_SOURCE == "external"'

stages:
  - sync
  - build
  - test
  - package
  - deploy

variables:
  DOTNET_VERSION: "8.0"
  DOTNET_SDK_VERSION: "8.0"
  NODE_VERSION: "22"
  NPM_VERSION: "10"
  # Solution and project paths
  SOLUTION_PATH: "azure-functions/azure-functions.sln"
  TEST_PROJECT: "tests/main.Core.Tests/main.Core.Tests.csproj"
  FRONTEND_PATH: "frontend"
  # Build configuration
  BUILD_CONFIGURATION: "Release"
  # Artifact paths
  ARTIFACTS_PATH: "artifacts"
  COVERAGE_PATH: "coverage"

# Cache configuration for faster builds
.dotnet_cache: &dotnet_cache
  cache:
    key: ${CI_COMMIT_REF_SLUG}-dotnet
    paths:
      - .nuget/
      - azure-functions/**/bin/
      - azure-functions/**/obj/
      - main.Core/**/bin/
      - main.Core/**/obj/
      - adapters/**/bin/
      - adapters/**/obj/
      - services/**/bin/
      - services/**/obj/
      - tests/**/bin/
      - tests/**/obj/

.node_cache: &node_cache
  cache:
    key: ${CI_COMMIT_REF_SLUG}-node
    paths:
      - frontend/node_modules/
      - node_modules/
      - api/node_modules/

# Branch filter: Only process branches starting with "ready/" OR main branch
# Feature branches must use "ready/" prefix (e.g., ready/myfeature)
# Main branch runs pipelines directly (no prefix needed)

# ============================================
# SYNC STAGE - Push commits to GitHub
# ============================================

sync:push-to-github:
  stage: sync
  image: alpine/git:latest
  variables:
    GIT_STRATEGY: clone
  before_script:
    - apk add --no-cache openssh-client || true
    - git config --global user.name "GitLab CI"
    - git config --global user.email "gitlab-ci@noreply.gitlab.com"
  script:
    - |
      echo "Syncing commits to GitHub..."
      
      # Check if GitHub remote is configured
      if ! git remote | grep -q "^github$"; then
        echo "Adding GitHub remote..."
        if [ -z "$GITHUB_REPO_URL" ]; then
          echo "‚ö†Ô∏è  GITHUB_REPO_URL not set. Please configure CI/CD variable:"
          echo "   - GITHUB_REPO_URL (e.g., https://github.com/mariomuja/interface-configurator.git)"
          echo "   Or use SSH: git@github.com:mariomuja/interface-configurator.git"
          exit 0
        fi
        
        # Add GitHub remote
        if [[ "$GITHUB_REPO_URL" == *"@"* ]]; then
          # SSH URL
          git remote add github "$GITHUB_REPO_URL" || git remote set-url github "$GITHUB_REPO_URL"
        else
          # HTTPS URL - use token if provided
          if [ -n "$GITHUB_TOKEN" ]; then
            GITHUB_URL_WITH_TOKEN=$(echo "$GITHUB_REPO_URL" | sed "s|https://|https://${GITHUB_TOKEN}@|")
            git remote add github "$GITHUB_URL_WITH_TOKEN" || git remote set-url github "$GITHUB_URL_WITH_TOKEN"
          else
            git remote add github "$GITHUB_REPO_URL" || git remote set-url github "$GITHUB_REPO_URL"
          fi
        fi
      fi
      
      # Fetch from GitHub to check what's there
      echo "Fetching from GitHub..."
      git fetch github --prune || echo "‚ö†Ô∏è  Could not fetch from GitHub (may need authentication)"
      
      # Get current branch name
      CURRENT_BRANCH="${CI_COMMIT_REF_NAME}"
      echo "Current branch: $CURRENT_BRANCH"
      
      # Push current branch to GitHub
      echo "Pushing branch '$CURRENT_BRANCH' to GitHub..."
      
      # Use force push for ready/* branches to ensure sync, regular push for main
      if [[ "$CURRENT_BRANCH" =~ ^ready/ ]]; then
        echo "Using force push for ready/* branch..."
        git push github "HEAD:$CURRENT_BRANCH" --force || {
          echo "‚ö†Ô∏è  Force push failed, trying regular push..."
          git push github "HEAD:$CURRENT_BRANCH" || {
            echo "‚ùå Failed to push to GitHub"
            echo "   This may be due to:"
            echo "   1. Authentication issues (check GITHUB_TOKEN or SSH keys)"
            echo "   2. Branch protection rules in GitHub"
            echo "   3. Divergent history"
            exit 0  # Don't fail the pipeline
          }
        }
      else
        echo "Using regular push for branch: $CURRENT_BRANCH"
        git push github "HEAD:$CURRENT_BRANCH" || {
          echo "‚ö†Ô∏è  Failed to push to GitHub"
          echo "   This may be due to:"
          echo "   1. Authentication issues (check GITHUB_TOKEN or SSH keys)"
          echo "   2. Branch protection rules in GitHub"
          echo "   3. Divergent history"
          exit 0  # Don't fail the pipeline
        }
      fi
      
      echo "‚úÖ Successfully pushed '$CURRENT_BRANCH' to GitHub"
      
      # Also push tags if any
      if git describe --tags --exact-match HEAD 2>/dev/null; then
        TAG=$(git describe --tags --exact-match HEAD)
        echo "Pushing tag '$TAG' to GitHub..."
        git push github "$TAG" || echo "‚ö†Ô∏è  Could not push tag (non-critical)"
      fi
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^ready\// || $CI_COMMIT_REF_NAME == "main"
      changes:
        - "**/*"
  allow_failure: true  # Don't block pipeline if GitHub sync fails
  needs: []  # Run immediately, no dependencies

# ============================================
# BUILD STAGE
# ============================================

build:dotnet:
  stage: build
  image: mcr.microsoft.com/dotnet/sdk:8.0
  <<: *dotnet_cache
  script:
    - echo "Restoring NuGet packages..."
    - dotnet restore $SOLUTION_PATH
    - echo "Building solution..."
    - dotnet build $SOLUTION_PATH --configuration $BUILD_CONFIGURATION --no-restore
    - echo "Build completed successfully"
  artifacts:
    paths:
      - azure-functions/**/bin/$BUILD_CONFIGURATION/
      - main.Core/**/bin/$BUILD_CONFIGURATION/
      - adapters/**/bin/$BUILD_CONFIGURATION/
      - services/**/bin/$BUILD_CONFIGURATION/
    expire_in: 1 hour
    when: on_success
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^ready\// || $CI_COMMIT_REF_NAME == "main"
      changes:
        - "azure-functions/**/*"
        - "main.Core/**/*"
        - "adapters/**/*"
        - "services/**/*"
        - ".gitlab-ci.yml"

build:frontend:
  stage: build
  image: node:${NODE_VERSION}
  <<: *node_cache
  before_script:
    - echo "Installing Node.js dependencies..."
    - cd $FRONTEND_PATH
    - npm ci
  script:
    - echo "Building Angular frontend..."
    - npm run build:prod
    - echo "Frontend build completed successfully"
  artifacts:
    paths:
      - frontend/dist/
    expire_in: 1 hour
    when: on_success
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^ready\// || $CI_COMMIT_REF_NAME == "main"
      changes:
        - "frontend/**/*"
        - "package.json"
        - "package-lock.json"
        - ".gitlab-ci.yml"

# ============================================
# TEST STAGE
# ============================================

test:dotnet:unit:
  stage: test
  image: mcr.microsoft.com/dotnet/sdk:8.0
  dependencies:
    - build:dotnet
  <<: *dotnet_cache
  script:
    - echo "Running all unit tests (excluding integration tests)..."
    - dotnet test $TEST_PROJECT 
        --configuration $BUILD_CONFIGURATION 
        --no-build 
        --verbosity normal
        --filter "FullyQualifiedName!~Integration"
        --logger "junit;LogFilePath=${CI_PROJECT_DIR}/test-results/junit-unit.xml"
        --collect:"XPlat Code Coverage"
        --results-directory:"${CI_PROJECT_DIR}/test-results"
    - echo "Unit tests completed"
  coverage: '/Total\s*\|\s*(\d+\.\d+)%/'
  artifacts:
    reports:
      junit: test-results/junit-unit.xml
      coverage_report:
        coverage_format: cobertura
        path: test-results/**/coverage.cobertura.xml
    paths:
      - test-results/
    expire_in: 30 days
    when: always
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^ready\// || $CI_COMMIT_REF_NAME == "main"
      changes:
        - "tests/**/*"
        - "main.Core/**/*"
        - "azure-functions/**/*"
        - "adapters/**/*"
        - ".gitlab-ci.yml"

test:dotnet:integration:
  stage: test
  image: mcr.microsoft.com/dotnet/sdk:8.0
  dependencies:
    - build:dotnet
  <<: *dotnet_cache
  script:
    - echo "Running all integration tests..."
    - dotnet test $TEST_PROJECT 
        --configuration $BUILD_CONFIGURATION 
        --no-build 
        --verbosity normal
        --filter "FullyQualifiedName~Integration"
        --logger "junit;LogFilePath=${CI_PROJECT_DIR}/test-results/junit-integration.xml"
    - echo "Integration tests completed"
  artifacts:
    reports:
      junit: test-results/junit-integration.xml
    paths:
      - test-results/
    expire_in: 30 days
    when: always
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^ready\// || $CI_COMMIT_REF_NAME == "main"
      changes:
        - "tests/**/*"
        - "main.Core/**/*"
        - "azure-functions/**/*"
        - "adapters/**/*"
        - ".gitlab-ci.yml"

test:frontend:
  stage: test
  image: node:${NODE_VERSION}
  dependencies:
    - build:frontend
  <<: *node_cache
  before_script:
    - cd $FRONTEND_PATH
    - npm ci
  script:
    - echo "Running frontend tests..."
    - npm test
    - echo "Frontend tests completed"
  artifacts:
    paths:
      - frontend/coverage/
    expire_in: 30 days
    when: always
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^ready\// || $CI_COMMIT_REF_NAME == "main"
      changes:
        - "frontend/**/*"
        - "package.json"
        - "package-lock.json"
        - ".gitlab-ci.yml"

test:playwright:
  stage: test
  image: node:${NODE_VERSION}
  dependencies:
    - build:frontend
  variables:
    CI: "true"
  before_script:
    - echo "Installing Node.js dependencies..."
    - npm ci
    - echo "Installing Playwright browsers and system dependencies..."
    - npx playwright install --with-deps chromium firefox webkit
    - echo "Playwright setup completed"
  script:
    - echo "Running all Playwright end-to-end tests..."
    - npx playwright test
    - echo "Playwright tests completed"
  artifacts:
    when: always
    paths:
      - playwright-report/
      - test-results/
    reports:
      junit: test-results/junit.xml
    expire_in: 30 days
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^ready\// || $CI_COMMIT_REF_NAME == "main"
      changes:
        - "tests/end-to-end/**/*"
        - "playwright.config.ts"
        - "package.json"
        - "package-lock.json"
        - "frontend/**/*"
        - ".gitlab-ci.yml"

# ============================================
# PACKAGE STAGE
# ============================================

package:adapter-containers:
  stage: package
  image: docker:24
  services:
    - docker:24-dind
  dependencies:
    - build:dotnet
    - test:dotnet:unit
    - test:dotnet:integration
  variables:
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_DRIVER: overlay2
  before_script:
    - echo "Setting up Docker and Azure Container Registry..."
    - apk add --no-cache curl bash
    # Install Azure CLI
    - apk add --no-cache python3 py3-pip
    - pip3 install --upgrade pip
    - pip3 install azure-cli
    - az --version
    # Login to Azure
    - |
      if [ -n "$AZURE_CLIENT_ID" ] && [ -n "$AZURE_CLIENT_SECRET" ] && [ -n "$AZURE_TENANT_ID" ]; then
        az login --service-principal -u "$AZURE_CLIENT_ID" -p "$AZURE_CLIENT_SECRET" --tenant "$AZURE_TENANT_ID"
        if [ -n "$AZURE_SUBSCRIPTION_ID" ]; then
          az account set --subscription "$AZURE_SUBSCRIPTION_ID"
        fi
        echo "‚úÖ Azure login successful"
        az account show
      else
        echo "‚ö†Ô∏è  Azure credentials not set. Please configure CI/CD variables:"
        echo "   - AZURE_CLIENT_ID"
        echo "   - AZURE_CLIENT_SECRET"
        echo "   - AZURE_TENANT_ID"
        exit 1
      fi
    # Login to Azure Container Registry
    - |
      if [ -z "$AZURE_CONTAINER_REGISTRY" ]; then
        echo "‚ö†Ô∏è  AZURE_CONTAINER_REGISTRY not set. Please configure CI/CD variable:"
        echo "   - AZURE_CONTAINER_REGISTRY (e.g., myregistry.azurecr.io or just myregistry)"
        exit 1
      fi
      # Extract registry name (remove .azurecr.io if present)
      ACR_NAME=$(echo "$AZURE_CONTAINER_REGISTRY" | sed 's/\.azurecr\.io$//')
      echo "Logging in to Azure Container Registry: $ACR_NAME"
      az acr login --name "$ACR_NAME"
      echo "‚úÖ ACR login successful"
  script:
    - echo "Building and pushing adapter container images to Azure Container Registry..."
    - |
      # Set image name and tag
      # Ensure ACR URL format (add .azurecr.io if not present)
      if [[ "$AZURE_CONTAINER_REGISTRY" == *.azurecr.io ]]; then
        ACR_URL="$AZURE_CONTAINER_REGISTRY"
      else
        ACR_URL="${AZURE_CONTAINER_REGISTRY}.azurecr.io"
      fi
      IMAGE_NAME="interface-configurator-adapters"
      IMAGE_TAG="${CI_COMMIT_REF_SLUG}-${CI_COMMIT_SHORT_SHA}"
      FULL_IMAGE_NAME="${ACR_URL}/${IMAGE_NAME}:${IMAGE_TAG}"
      LATEST_TAG="${ACR_URL}/${IMAGE_NAME}:latest"
      
      echo "Building Docker image: $FULL_IMAGE_NAME"
      echo "Dockerfile: docker/Dockerfile.adapter"
      
      # Build the Docker image
      docker build \
        -f docker/Dockerfile.adapter \
        -t "$FULL_IMAGE_NAME" \
        -t "$LATEST_TAG" \
        --build-arg BUILD_CONFIGURATION="$BUILD_CONFIGURATION" \
        .
      
      echo "‚úÖ Docker image built successfully"
      
      # Push both tags
      echo "Pushing image with tag: $IMAGE_TAG"
      docker push "$FULL_IMAGE_NAME"
      
      echo "Pushing image with tag: latest"
      docker push "$LATEST_TAG"
      
      echo "‚úÖ Adapter container images pushed successfully to ACR"
      echo ""
      echo "Image details:"
      echo "  - Tagged: $FULL_IMAGE_NAME"
      echo "  - Latest: $LATEST_TAG"
      echo "  - Registry: $AZURE_CONTAINER_REGISTRY"
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^ready\// || $CI_COMMIT_REF_NAME == "main"
      changes:
        - "adapters/**/*"
        - "main.Core/**/*"
        - "docker/**/*"
        - ".gitlab-ci.yml"
      when: on_success
  needs:
    - job: build:dotnet
      artifacts: true
    - job: test:dotnet:unit
      artifacts: false
    - job: test:dotnet:integration
      artifacts: false

package:dotnet:
  stage: package
  image: mcr.microsoft.com/dotnet/sdk:8.0
  dependencies:
    - build:dotnet
    - test:dotnet:unit
  script:
    - echo "Packaging .NET artifacts..."
    - mkdir -p $ARTIFACTS_PATH
    - |
      cd azure-functions/main
      dotnet publish --configuration $BUILD_CONFIGURATION --output ../../$ARTIFACTS_PATH/azure-functions
    - |
      cd main.Core
      dotnet publish --configuration $BUILD_CONFIGURATION --output ../$ARTIFACTS_PATH/main.Core
    - echo "Packaging completed"
  artifacts:
    paths:
      - $ARTIFACTS_PATH/
    expire_in: 1 week
    when: on_success
  rules:
    - if: $CI_COMMIT_REF_NAME == "main" || $CI_COMMIT_TAG

package:frontend:
  stage: package
  image: node:${NODE_VERSION}
  dependencies:
    - build:frontend
    - test:frontend
  script:
    - echo "Packaging frontend artifacts..."
    - mkdir -p $ARTIFACTS_PATH
    - cp -r frontend/dist $ARTIFACTS_PATH/frontend
    - echo "Frontend packaging completed"
  artifacts:
    paths:
      - $ARTIFACTS_PATH/frontend/
    expire_in: 1 week
    when: on_success
  rules:
    - if: $CI_COMMIT_REF_NAME == "main" || $CI_COMMIT_TAG

# ============================================
# DEPLOY STAGE (Manual - Configure as needed)
# ============================================


deploy:production:
  stage: deploy
  image: mcr.microsoft.com/dotnet/sdk:8.0
  dependencies:
    - package:dotnet
    - package:frontend
  before_script:
    - echo "Setting up deployment environment..."
    - apt-get update
    - apt-get install -y curl gnupg lsb-release
    # Install Azure CLI
    - curl -sL https://aka.ms/InstallAzureCLIDeb | bash
    # Install Azure Functions Core Tools
    - curl https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor > /etc/apt/trusted.gpg.d/microsoft.gpg
    - sh -c 'echo "deb [arch=amd64] https://packages.microsoft.com/repos/microsoft-ubuntu-$(lsb_release -cs)-prod $(lsb_release -cs) main" > /etc/apt/sources.list.d/dotnetdev.list'
    - apt-get update
    - apt-get install -y azure-functions-core-tools-4
    - echo "‚úÖ Azure Functions Core Tools installed"
    - func --version
    - echo "Logging in to Azure..."
    # Login to Azure using service principal
    - |
      if [ -n "$AZURE_CLIENT_ID" ] && [ -n "$AZURE_CLIENT_SECRET" ] && [ -n "$AZURE_TENANT_ID" ]; then
        az login --service-principal -u "$AZURE_CLIENT_ID" -p "$AZURE_CLIENT_SECRET" --tenant "$AZURE_TENANT_ID"
        if [ -n "$AZURE_SUBSCRIPTION_ID" ]; then
          az account set --subscription "$AZURE_SUBSCRIPTION_ID"
        fi
        echo "‚úÖ Azure login successful"
        az account show
      else
        echo "‚ö†Ô∏è  Azure credentials not set. Please configure CI/CD variables:"
        echo "   - AZURE_CLIENT_ID"
        echo "   - AZURE_CLIENT_SECRET"
        echo "   - AZURE_TENANT_ID"
        exit 1
      fi
  script:
    - echo "Deploying Azure Function App to production..."
    - |
      cd azure-functions/main
      echo "Step 1: Publishing Function App (--self-contained false)..."
      dotnet publish --self-contained false --configuration $BUILD_CONFIGURATION --output ./publish
      echo "‚úÖ Publish completed"
    - |
      cd azure-functions/main
      echo "Step 2: Deploying to Azure Function App..."
      if [ -z "$AZURE_FUNCTION_APP_NAME" ] || [ -z "$AZURE_RESOURCE_GROUP" ]; then
        echo "‚ö†Ô∏è  Required CI/CD variables not set:"
        echo "   - AZURE_FUNCTION_APP_NAME"
        echo "   - AZURE_RESOURCE_GROUP"
        exit 1
      fi
      echo "Function App: $AZURE_FUNCTION_APP_NAME"
      echo "Resource Group: $AZURE_RESOURCE_GROUP"
      echo "Deploying with: func azure functionapp publish --dotnet-isolated"
      func azure functionapp publish "$AZURE_FUNCTION_APP_NAME" --dotnet-isolated
      echo "‚úÖ Deployment completed successfully"
      echo ""
      echo "Function App URL: https://${AZURE_FUNCTION_APP_NAME}.azurewebsites.net"
  environment:
    name: production
    url: https://${AZURE_FUNCTION_APP_NAME}.azurewebsites.net
  rules:
    - if: $CI_COMMIT_REF_NAME == "main" || $CI_COMMIT_TAG
      when: on_success

deploy:vercel:
  stage: deploy
  image: node:22
  dependencies:
    - package:frontend
  before_script:
    - echo "Setting up Vercel deployment..."
    - npm install -g vercel@latest
    - vercel --version
  script:
    - echo "Deploying static web app to Vercel..."
    - |
      if [ -z "$VERCEL_TOKEN" ]; then
        echo "‚ö†Ô∏è  VERCEL_TOKEN not set. Please configure CI/CD variable:"
        echo "   - VERCEL_TOKEN (get from https://vercel.com/account/tokens)"
        exit 1
      fi
    - |
      # Set Vercel environment variables
      export VERCEL_ORG_ID="${VERCEL_ORG_ID:-}"
      export VERCEL_PROJECT_ID="${VERCEL_PROJECT_ID:-}"
      
      # Deploy to Vercel production
      echo "Deploying to Vercel production..."
      vercel deploy --prod --token "$VERCEL_TOKEN" --yes
      
      if [ $? -eq 0 ]; then
        echo "‚úÖ Vercel deployment completed successfully"
      else
        echo "‚ùå Vercel deployment failed"
        exit 1
      fi
  environment:
    name: vercel-production
    url: https://${VERCEL_PROJECT_NAME:-interface-configurator}.vercel.app
  rules:
    - if: $CI_COMMIT_REF_NAME == "main" || $CI_COMMIT_TAG
      when: on_success

deploy:azure-static-web-app:
  stage: deploy
  image: node:22
  dependencies:
    - package:frontend
  before_script:
    - echo "Setting up Azure Static Web App deployment..."
    - echo "Installing Azure CLI..."
    - apt-get update
    - apt-get install -y curl gnupg lsb-release ca-certificates
    - curl -sL https://aka.ms/InstallAzureCLIDeb | bash
    - az --version
    - echo "Installing Azure Static Web Apps CLI..."
    - npm install -g @azure/static-web-apps-cli
    - swa --version
    - echo "Logging in to Azure..."
    - |
      if [ -n "$AZURE_CLIENT_ID" ] && [ -n "$AZURE_CLIENT_SECRET" ] && [ -n "$AZURE_TENANT_ID" ]; then
        az login --service-principal -u "$AZURE_CLIENT_ID" -p "$AZURE_CLIENT_SECRET" --tenant "$AZURE_TENANT_ID"
        if [ -n "$AZURE_SUBSCRIPTION_ID" ]; then
          az account set --subscription "$AZURE_SUBSCRIPTION_ID"
        fi
        echo "‚úÖ Azure login successful"
        az account show
      else
        echo "‚ö†Ô∏è  Azure credentials not set. Please configure CI/CD variables:"
        echo "   - AZURE_CLIENT_ID"
        echo "   - AZURE_CLIENT_SECRET"
        echo "   - AZURE_TENANT_ID"
        exit 1
      fi
  script:
    - echo "Deploying static web app to Azure Static Web Apps..."
    - |
      if [ -z "$AZURE_STATIC_WEB_APP_NAME" ] || [ -z "$AZURE_RESOURCE_GROUP" ]; then
        echo "‚ö†Ô∏è  Required CI/CD variables not set:"
        echo "   - AZURE_STATIC_WEB_APP_NAME"
        echo "   - AZURE_RESOURCE_GROUP"
        exit 1
      fi
    - |
      # Get deployment token - prefer CI/CD variable, otherwise retrieve from Azure
      if [ -n "$DEPLOYMENT_TOKEN" ]; then
        FINAL_DEPLOYMENT_TOKEN="$DEPLOYMENT_TOKEN"
        echo "‚úÖ Using deployment token from CI/CD variable"
      else
        echo "Retrieving deployment token from Azure Static Web App..."
        RETRIEVED_TOKEN=$(az staticwebapp secrets list \
          --name "$AZURE_STATIC_WEB_APP_NAME" \
          --resource-group "$AZURE_RESOURCE_GROUP" \
          --query "properties.apiKey" -o tsv 2>/dev/null || echo "")
        
        if [ -z "$RETRIEVED_TOKEN" ]; then
          echo "‚ö†Ô∏è  Could not retrieve deployment token via secrets. Trying alternative method..."
          # Alternative: Get from app settings
          RETRIEVED_TOKEN=$(az staticwebapp appsettings list \
            --name "$AZURE_STATIC_WEB_APP_NAME" \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --query "[?name=='DEPLOYMENT_TOKEN'].value" -o tsv 2>/dev/null || echo "")
        fi
        
        if [ -z "$RETRIEVED_TOKEN" ]; then
          echo "‚ùå Could not retrieve deployment token from Azure"
          echo "   Please set DEPLOYMENT_TOKEN as a CI/CD variable"
          echo "   Or ensure the Azure Static Web App has a deployment token configured"
          exit 1
        fi
        
        FINAL_DEPLOYMENT_TOKEN="$RETRIEVED_TOKEN"
        echo "‚úÖ Using deployment token retrieved from Azure"
      fi
    - |
      # Deploy using SWA CLI
      echo "Deploying to Azure Static Web App..."
      echo "Static Web App: $AZURE_STATIC_WEB_APP_NAME"
      echo "Resource Group: $AZURE_RESOURCE_GROUP"
      
      # Use the packaged frontend artifacts
      # The artifacts are in $ARTIFACTS_PATH/frontend/dist/ from package:frontend job
      # package:frontend copies frontend/dist to $ARTIFACTS_PATH/frontend
      # So the structure is: $ARTIFACTS_PATH/frontend/dist/interface-configuration/browser
      ARTIFACTS_BASE="${ARTIFACTS_PATH:-artifacts}/frontend/dist"
      BROWSER_DIR="$ARTIFACTS_BASE/interface-configuration/browser"
      
      if [ ! -d "$BROWSER_DIR" ]; then
        echo "‚ö†Ô∏è  Frontend artifacts not found at $BROWSER_DIR"
        echo "   Building frontend now..."
        cd frontend
        npm ci
        npm run build:prod
        BROWSER_DIR="frontend/dist/interface-configuration/browser"
      fi
      
      echo "Deploying from: $BROWSER_DIR"
      
      # Deploy using SWA CLI
      swa deploy "$BROWSER_DIR" \
        --app-name "$AZURE_STATIC_WEB_APP_NAME" \
        --resource-group "$AZURE_RESOURCE_GROUP" \
        --deployment-token "$FINAL_DEPLOYMENT_TOKEN" \
        --env production \
        --no-use-keychain
      
      if [ $? -eq 0 ]; then
        echo "‚úÖ Azure Static Web App deployment completed successfully"
        echo ""
        echo "Static Web App URL: https://${AZURE_STATIC_WEB_APP_NAME}.azurestaticapps.net"
      else
        echo "‚ùå Azure Static Web App deployment failed"
        exit 1
      fi
  environment:
    name: azure-static-web-app-production
    url: https://${AZURE_STATIC_WEB_APP_NAME}.azurestaticapps.net
  rules:
    - if: $CI_COMMIT_REF_NAME == "main" || $CI_COMMIT_TAG
      when: on_success

# ============================================
# CLEANUP
# ============================================

cleanup:delete-merged-ready-branch:
  stage: deploy
  image: curlimages/curl:latest
  variables:
    CI: "true"
  before_script:
    - apk add --no-cache git || true
  script:
    - |
      echo "Cleaning up merged ready/* branch..."
      
      # Only run if this is a merge to main
      if [ "$CI_COMMIT_REF_NAME" != "main" ]; then
        echo "Not on main branch, skipping cleanup"
        exit 0
      fi
      
      # Try multiple methods to detect merged branch
      SOURCE_BRANCH=""
      
      # Method 1: Check merge commit message (GitLab format)
      if git log -1 --pretty=%B | grep -q "Merge branch"; then
        SOURCE_BRANCH=$(git log -1 --pretty=%B | grep -oP "Merge branch ['\"]\Kready/[^'\"]+" | head -1 || echo "")
      fi
      
      # Method 2: Check if merge commit has two parents (indicates merge)
      PARENT_COUNT=$(git log -1 --pretty=%P | wc -w)
      if [ "$PARENT_COUNT" -eq 2 ]; then
        # Get the second parent (the merged branch)
        MERGED_BRANCH=$(git log -1 --pretty=%P | awk '{print $2}')
        if [ -n "$MERGED_BRANCH" ]; then
          # Try to find branch name from commit
          SOURCE_BRANCH=$(git branch -r --contains $MERGED_BRANCH | grep "ready/" | head -1 | sed 's|origin/||' | xargs || echo "")
        fi
      fi
      
      # Method 3: Check recent merge requests via API (if token available)
      if [ -z "$SOURCE_BRANCH" ] && [ -n "$GITLAB_TOKEN" ] && [ -n "$CI_PROJECT_ID" ]; then
        echo "Checking recent merge requests via API..."
        RECENT_MR=$(curl -s --header "PRIVATE-TOKEN: $GITLAB_TOKEN" \
          "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests?state=merged&target_branch=main&per_page=1" | \
          grep -oP '"source_branch":"\Kready/[^"]+' | head -1 || echo "")
        if [ -n "$RECENT_MR" ]; then
          SOURCE_BRANCH="$RECENT_MR"
        fi
      fi
      
      # If we found a ready/* branch, delete it
      if [[ "$SOURCE_BRANCH" =~ ^ready/ ]]; then
        echo "Found ready/* branch to delete: $SOURCE_BRANCH"
        
        # Delete branch using GitLab API
        if [ -n "$GITLAB_TOKEN" ] && [ -n "$CI_PROJECT_ID" ]; then
          echo "Deleting branch $SOURCE_BRANCH from origin..."
          DELETE_RESPONSE=$(curl -s -w "\n%{http_code}" -X DELETE \
            --header "PRIVATE-TOKEN: $GITLAB_TOKEN" \
            "$CI_API_V4_URL/projects/$CI_PROJECT_ID/repository/branches/$(echo $SOURCE_BRANCH | sed 's|/|%2F|g')")
          
          HTTP_CODE=$(echo "$DELETE_RESPONSE" | tail -1)
          if [ "$HTTP_CODE" = "204" ] || [ "$HTTP_CODE" = "200" ]; then
            echo "‚úÖ Branch $SOURCE_BRANCH deleted successfully"
          elif [ "$HTTP_CODE" = "404" ]; then
            echo "‚ÑπÔ∏è  Branch $SOURCE_BRANCH already deleted or doesn't exist"
          else
            echo "‚ö†Ô∏è  Failed to delete branch (HTTP $HTTP_CODE)"
            echo "   Response: $(echo "$DELETE_RESPONSE" | head -n -1)"
          fi
        else
          echo "‚ö†Ô∏è  GITLAB_TOKEN not set. Cannot delete branch automatically."
          echo "   Branch $SOURCE_BRANCH should be deleted via merge request settings"
          echo "   Or set GITLAB_TOKEN in CI/CD Variables"
        fi
      else
        echo "‚ÑπÔ∏è  No ready/* branch detected to delete"
        echo "   (This is normal if branch was already deleted or merge used different method)"
      fi
  rules:
    - if: $CI_COMMIT_REF_NAME == "main"
      when: on_success
  allow_failure: true
  needs:
    - job: package:dotnet
      optional: true
    - job: package:frontend
      optional: true

# ============================================
# NOTIFICATIONS
# ============================================

notify:email:on-failure:
  stage: test
  image: curlimages/curl:latest
  variables:
    CI: "true"
  before_script:
    - apk add --no-cache jq bash
  script:
    - |
      echo "Sending failure notification email to commit author..."
      
      # Only run for ready/* branches
      if [[ ! "$CI_COMMIT_REF_NAME" =~ ^ready/ ]]; then
        echo "Not a ready/* branch, skipping email notification"
        exit 0
      fi
      
      # Get commit author email from GitLab API
      if [ -z "$GITLAB_TOKEN" ]; then
        echo "‚ö†Ô∏è  GITLAB_TOKEN not set. Cannot retrieve commit author email."
        echo "   Email notification will be skipped."
        exit 0
      fi
      
      echo "Fetching commit author information..."
      COMMIT_INFO=$(curl -s --header "PRIVATE-TOKEN: $GITLAB_TOKEN" \
        "$CI_API_V4_URL/projects/$CI_PROJECT_ID/repository/commits/$CI_COMMIT_SHA")
      
      AUTHOR_EMAIL=$(echo "$COMMIT_INFO" | jq -r '.author_email // empty')
      AUTHOR_NAME=$(echo "$COMMIT_INFO" | jq -r '.author_name // "Developer"')
      
      if [ -z "$AUTHOR_EMAIL" ] || [ "$AUTHOR_EMAIL" == "null" ]; then
        echo "‚ö†Ô∏è  Could not retrieve commit author email from GitLab API"
        echo "   Commit info: $COMMIT_INFO"
        exit 0
      fi
      
      echo "Commit author: $AUTHOR_NAME <$AUTHOR_EMAIL>"
      echo "Branch: $CI_COMMIT_REF_NAME"
      echo "Pipeline: $CI_PIPELINE_ID"
      
      # Build email content
      PIPELINE_URL="${CI_PROJECT_URL}/-/pipelines/${CI_PIPELINE_ID}"
      BRANCH_NAME="${CI_COMMIT_REF_NAME}"
      PROJECT_NAME="${CI_PROJECT_NAME}"
      
      SUBJECT="üö® Pipeline Failed: ${BRANCH_NAME} - ${PROJECT_NAME}"
      MESSAGE="Pipeline failed for your ready branch: ${BRANCH_NAME}
      
Project: ${PROJECT_NAME}
Branch: ${BRANCH_NAME}
Pipeline ID: ${CI_PIPELINE_ID}
Pipeline URL: ${PIPELINE_URL}
Commit: ${CI_COMMIT_SHORT_SHA}
Commit Message: $(echo "$COMMIT_INFO" | jq -r '.message // "N/A"' | head -1)

Please check the pipeline logs and fix the issues.

Pipeline URL: ${PIPELINE_URL}"
      
      # Send email via configured email service
      if [ -n "$EMAIL_API_URL" ] && [ -n "$EMAIL_API_KEY" ]; then
        echo "Sending email to $AUTHOR_EMAIL via email service API..."
        
        # Construct email payload (adjust based on your email service API)
        EMAIL_PAYLOAD=$(jq -n \
          --arg to "$AUTHOR_EMAIL" \
          --arg subject "$SUBJECT" \
          --arg body "$MESSAGE" \
          '{
            "to": $to,
            "subject": $subject,
            "body": $body,
            "from": "noreply@gitlab-ci"
          }')
        
        HTTP_CODE=$(curl -s -w "\n%{http_code}" -X POST "$EMAIL_API_URL" \
          -H "Authorization: Bearer $EMAIL_API_KEY" \
          -H "Content-Type: application/json" \
          -d "$EMAIL_PAYLOAD" | tail -1)
        
        if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "201" ] || [ "$HTTP_CODE" = "202" ]; then
          echo "‚úÖ Email sent successfully to $AUTHOR_EMAIL"
        else
          echo "‚ö†Ô∏è  Email sending failed (HTTP $HTTP_CODE)"
          echo "   Email would have been sent to: $AUTHOR_EMAIL"
        fi
      elif [ -n "$SMTP_HOST" ] && [ -n "$SMTP_USER" ] && [ -n "$SMTP_PASSWORD" ]; then
        echo "Sending email via SMTP to $AUTHOR_EMAIL..."
        
        # Use sendmail or similar (if available) or curl with SMTP
        # For simplicity, we'll use a basic SMTP approach
        # Note: This requires additional tools. For production, use a proper email service.
        echo "‚ö†Ô∏è  Direct SMTP sending not implemented. Please use EMAIL_API_URL or configure GitLab project notifications."
        echo "   Email would have been sent to: $AUTHOR_EMAIL"
      else
        echo "‚ö†Ô∏è  Email service not configured. Please set one of:"
        echo "   Option 1: EMAIL_API_URL and EMAIL_API_KEY (for email service API)"
        echo "   Option 2: SMTP_HOST, SMTP_USER, SMTP_PASSWORD (for SMTP)"
        echo "   Option 3: Configure GitLab project-level email notifications"
        echo ""
        echo "   Email would have been sent to: $AUTHOR_EMAIL"
        echo "   Subject: $SUBJECT"
        echo "   Pipeline URL: $PIPELINE_URL"
      fi
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^ready\//
      when: on_failure  # Only run when previous jobs fail
  allow_failure: true  # Don't block pipeline if email fails
  needs:
    - job: build:dotnet
      optional: true
    - job: test:dotnet:unit
      optional: true
    - job: test:dotnet:integration
      optional: true
    - job: test:frontend
      optional: true
    - job: test:playwright
      optional: true

notify:sms:
  stage: test
  image: curlimages/curl:latest
  variables:
    CI: "true"
  script:
    - |
      echo "Sending SMS notification for test failures..."
      # Extract branch name
      BRANCH_NAME="${CI_COMMIT_REF_NAME}"
      PIPELINE_URL="${CI_PROJECT_URL}/-/pipelines/${CI_PIPELINE_ID}"
      
      # SMS message
      MESSAGE="üö® Test failures in ready branch: ${BRANCH_NAME}. Pipeline: ${PIPELINE_URL}"
      
      # Send SMS via API (configure your SMS service)
      # Example using generic HTTP API
      if [ -n "$SMS_API_URL" ] && [ -n "$SMS_API_KEY" ] && [ -n "$SMS_PHONE_NUMBER" ]; then
        curl -X POST "$SMS_API_URL" \
          -H "Authorization: Bearer $SMS_API_KEY" \
          -H "Content-Type: application/json" \
          -d "{
            \"to\": \"$SMS_PHONE_NUMBER\",
            \"message\": \"$MESSAGE\"
          }" || echo "SMS sending failed, but continuing..."
      else
        echo "SMS variables not configured. Skipping SMS notification."
        echo "To enable SMS, set: SMS_API_URL, SMS_API_KEY, SMS_PHONE_NUMBER"
      fi
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^ready\//
      when: on_failure  # Only run when previous jobs fail
  allow_failure: true  # Don't block pipeline if SMS fails
  needs:
    - job: test:dotnet:unit
      optional: true
    - job: test:dotnet:integration
      optional: true
    - job: test:frontend
      optional: true
    - job: test:playwright
      optional: true

# ============================================
# CODE QUALITY (Optional)
# ============================================

lint:dotnet:
  stage: test
  image: mcr.microsoft.com/dotnet/sdk:8.0
  <<: *dotnet_cache
  script:
    - echo "Running .NET code analysis..."
    - dotnet format $SOLUTION_PATH --verify-no-changes --verbosity diagnostic || true
    - echo "Code analysis completed"
  allow_failure: true
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^ready\// || $CI_COMMIT_REF_NAME == "main"
      changes:
        - "azure-functions/**/*.cs"
        - "main.Core/**/*.cs"
        - "adapters/**/*.cs"
        - ".gitlab-ci.yml"

lint:frontend:
  stage: test
  image: node:${NODE_VERSION}
  <<: *node_cache
  before_script:
    - cd $FRONTEND_PATH
    - npm ci
  script:
    - echo "Running frontend linting..."
    - npm run lint || true
    - echo "Linting completed"
  allow_failure: true
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^ready\// || $CI_COMMIT_REF_NAME == "main"
      changes:
        - "frontend/**/*.ts"
        - "frontend/**/*.html"
        - ".gitlab-ci.yml"

#   T r i g g e r   G i t L a b   m i r r o r   s y n c 
 
 #   T r i g g e r   s y n c   a f t e r   t o k e n   u p d a t e 
 
 