# GitLab CI/CD Pipeline for Interface Configurator
# This pipeline builds, tests, and optionally deploys the application

# Workflow rules: Always run pipelines on push events (including from mirroring)
# This ensures pipelines run for all push events, including mirrored branches
# Note: GitLab mirroring may not trigger pipelines automatically - you may need to
# manually trigger or enable "Trigger pipelines for mirror updates" in mirror settings
workflow:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "push"'
    - if: '$CI_PIPELINE_SOURCE == "web"'
    - if: '$CI_PIPELINE_SOURCE == "api"'
    - if: '$CI_PIPELINE_SOURCE == "trigger"'
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
    - if: '$CI_PIPELINE_SOURCE == "external"'

stages:
  - build
  - test
  - version
  - package
  - deploy
  - test:post-deploy

variables:
  DOTNET_VERSION: "8.0"
  DOTNET_SDK_VERSION: "8.0"
  NODE_VERSION: "22"
  NPM_VERSION: "10"
  # Solution and project paths
  SOLUTION_PATH: "azure-functions/azure-functions.sln"
  TEST_PROJECT: "tests/main.Core.Tests/main.Core.Tests.csproj"
  FRONTEND_PATH: "frontend"
  # Build configuration
  BUILD_CONFIGURATION: "Release"
  # Artifact paths
  ARTIFACTS_PATH: "artifacts"
  COVERAGE_PATH: "coverage"

# Cache configuration for faster builds
.dotnet_cache: &dotnet_cache
  cache:
    key: ${CI_COMMIT_REF_SLUG}-dotnet
    paths:
      - .nuget/
      - azure-functions/**/bin/
      - azure-functions/**/obj/
      - main.Core/**/bin/
      - main.Core/**/obj/
      - adapters/**/bin/
      - adapters/**/obj/
      - services/**/bin/
      - services/**/obj/
      - tests/**/bin/
      - tests/**/obj/

.node_cache: &node_cache
  cache:
    key: ${CI_COMMIT_REF_SLUG}-node
    paths:
      - frontend/node_modules/
      - node_modules/
      - api/node_modules/

# Branch filter: Only process branches starting with "ready/" OR main branch
# Feature branches must use "ready/" prefix (e.g., ready/myfeature)
# Main branch runs pipelines directly (no prefix needed)

# ============================================
# BUILD STAGE
# ============================================

build:dotnet:
  stage: build
  image: mcr.microsoft.com/dotnet/sdk:8.0
  <<: *dotnet_cache
  script:
    - echo "Restoring NuGet packages..."
    - dotnet restore $SOLUTION_PATH
    - echo "Building solution..."
    - dotnet build $SOLUTION_PATH --configuration $BUILD_CONFIGURATION --no-restore
    - echo "Build completed successfully"
  artifacts:
    paths:
      - azure-functions/**/bin/$BUILD_CONFIGURATION/
      - main.Core/**/bin/$BUILD_CONFIGURATION/
      - adapters/**/bin/$BUILD_CONFIGURATION/
      - services/**/bin/$BUILD_CONFIGURATION/
    expire_in: 1 hour
    when: on_success
  rules:
    # Always run build on ready/* or main branches (ensures tests can always run)
    - if: $CI_COMMIT_REF_NAME =~ /^ready\// || $CI_COMMIT_REF_NAME == "main"

build:frontend:
  stage: build
  image: node:${NODE_VERSION}
  <<: *node_cache
  before_script:
    - echo "Installing Node.js dependencies..."
    - cd $FRONTEND_PATH
    - npm ci
  script:
    - echo "Building Angular frontend..."
    - npm run build:prod
    - echo "Frontend build completed successfully"
  artifacts:
    paths:
      - frontend/dist/
    expire_in: 1 hour
    when: on_success
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^ready\// || $CI_COMMIT_REF_NAME == "main"
      changes:
        - "frontend/**/*"
        - "package.json"
        - "package-lock.json"
        - ".gitlab-ci.yml"

# ============================================
# TEST STAGE
# ============================================

test:dotnet:unit:
  stage: test
  image: mcr.microsoft.com/dotnet/sdk:8.0
  dependencies:
    - build:dotnet
  <<: *dotnet_cache
  script:
    - echo "Running all unit tests (excluding integration tests)..."
    - mkdir -p test-results
    - dotnet test $TEST_PROJECT 
        --configuration $BUILD_CONFIGURATION 
        --verbosity normal
        --filter "FullyQualifiedName!~Integration"
        --logger "junit;LogFilePath=${CI_PROJECT_DIR}/test-results/junit-unit.xml"
        --collect:"XPlat Code Coverage"
        --results-directory:"${CI_PROJECT_DIR}/test-results"
    - echo "Unit tests completed"
    - |
      # Ensure test-results directory exists even if tests fail
      mkdir -p test-results
      # Find and copy coverage files if they exist
      if [ -d "test-results" ]; then
        find test-results -name "coverage.cobertura.xml" -type f | head -1 | xargs -I {} cp {} test-results/coverage.cobertura.xml 2>/dev/null || true
      fi
  coverage: '/Total\s*\|\s*(\d+\.\d+)%/'
  artifacts:
    reports:
      junit: test-results/junit-unit.xml
      coverage_report:
        coverage_format: cobertura
        path: test-results/coverage.cobertura.xml
    paths:
      - test-results/
    expire_in: 30 days
    when: always
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^ready\// || $CI_COMMIT_REF_NAME == "main"
      changes:
        - "tests/**/*"
        - "main.Core/**/*"
        - "azure-functions/**/*"
        - "adapters/**/*"
        - ".gitlab-ci.yml"

test:mutation:
  stage: test
  image: mcr.microsoft.com/dotnet/sdk:8.0
  dependencies:
    - build:dotnet
    - test:dotnet:unit
  <<: *dotnet_cache
  variables:
    STRYKER_PROJECT: "main.Core/main.Core.csproj"
    STRYKER_TEST_PROJECT: "tests/main.Core.Tests/main.Core.Tests.csproj"
  before_script:
    - echo "Installing Stryker.NET mutation testing tool..."
    - dotnet tool install -g dotnet-stryker
    - export PATH="$PATH:/root/.dotnet/tools"
    - dotnet-stryker --version
    - echo "Setting up mutation testing environment..."
    - mkdir -p mutation-reports
  script:
    - echo "Running mutation tests with Stryker.NET..."
    - echo "Testing project: $STRYKER_PROJECT"
    - echo "Test project: $STRYKER_TEST_PROJECT"
    - |
      cd main.Core
      dotnet-stryker \
        --test-project "../$STRYKER_TEST_PROJECT" \
        --reporters "html" "json" "progress" \
        --output "../mutation-reports" \
        --log-level "info" \
        --threshold-break 60 \
        --threshold-high 70 \
        --threshold-low 60 \
        --mutation-level "Standard" || true
    - echo "Mutation testing completed"
    - cd ..
    - |
      # Check if mutation report was generated
      if [ -f "mutation-reports/mutation-report.json" ]; then
        echo "‚úÖ Mutation report generated successfully"
        # Extract mutation score from JSON report
        MUTATION_SCORE=$(cat mutation-reports/mutation-report.json | grep -o '"mutationScore":[0-9.]*' | cut -d':' -f2 || echo "0")
        echo "Mutation Score: $MUTATION_SCORE%"
      else
        echo "‚ö†Ô∏è  Mutation report not found"
      fi
  artifacts:
    when: always
    paths:
      - mutation-reports/
    reports:
      junit: mutation-reports/mutation-report.xml
    expire_in: 30 days
  coverage: '/Mutation score: (\d+\.\d+)%/'
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^ready\// || $CI_COMMIT_REF_NAME == "main"
      changes:
        - "main.Core/**/*"
        - "tests/main.Core.Tests/**/*"
        - ".gitlab-ci.yml"
      when: on_success
  allow_failure: true
  needs:
    - job: build:dotnet
      artifacts: true
    - job: test:dotnet:unit
      artifacts: false

test:frontend:
  stage: test
  image: node:${NODE_VERSION}
  dependencies:
    - build:frontend
  <<: *node_cache
  before_script:
    - cd $FRONTEND_PATH
    - npm ci
  script:
    - echo "Running frontend tests..."
    - npm test
    - echo "Frontend tests completed"
  artifacts:
    paths:
      - frontend/coverage/
    expire_in: 30 days
    when: always
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^ready\// || $CI_COMMIT_REF_NAME == "main"
      changes:
        - "frontend/**/*"
        - "package.json"
        - "package-lock.json"
        - ".gitlab-ci.yml"

test:e2e:
  stage: test
  image: node:${NODE_VERSION}
  dependencies:
    - build:frontend
  <<: *node_cache
  variables:
    CI: "true"
  before_script:
    - echo "Installing Node.js dependencies..."
    - npm ci
    - echo "Installing Playwright browsers and system dependencies..."
    - npx playwright install --with-deps chromium firefox webkit
    - echo "Playwright setup completed"
    - mkdir -p test-results
  script:
    - echo "Running end-to-end tests with Playwright..."
    - npx playwright test
    - echo "End-to-end tests completed"
  artifacts:
    when: always
    paths:
      - playwright-report/
      - test-results/
    reports:
      junit: test-results/junit.xml
    expire_in: 30 days
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^ready\// || $CI_COMMIT_REF_NAME == "main"
      changes:
        - "tests/end-to-end/**/*"
        - "playwright.config.ts"
        - "package.json"
        - "package-lock.json"
        - "frontend/**/*"
        - ".gitlab-ci.yml"

# ============================================
# PACKAGE STAGE
# ============================================

package:adapter-containers:
  stage: package
  image: docker:24
  services:
    - docker:24-dind
  dependencies:
    - build:dotnet
    - test:dotnet:unit
  variables:
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_DRIVER: overlay2
  before_script:
    - echo "Setting up Docker and Azure Container Registry..."
    - apk add --no-cache curl bash
    # Install Azure CLI
    - apk add --no-cache python3 py3-pip
    - pip3 install --upgrade pip
    - pip3 install azure-cli
    - az --version
    # Login to Azure
    - |
      if [ -n "$AZURE_CLIENT_ID" ] && [ -n "$AZURE_CLIENT_SECRET" ] && [ -n "$AZURE_TENANT_ID" ]; then
        az login --service-principal -u "$AZURE_CLIENT_ID" -p "$AZURE_CLIENT_SECRET" --tenant "$AZURE_TENANT_ID"
        if [ -n "$AZURE_SUBSCRIPTION_ID" ]; then
          az account set --subscription "$AZURE_SUBSCRIPTION_ID"
        fi
        echo "‚úÖ Azure login successful"
        az account show
      else
        echo "‚ö†Ô∏è  Azure credentials not set. Please configure CI/CD variables:"
        echo "   - AZURE_CLIENT_ID"
        echo "   - AZURE_CLIENT_SECRET"
        echo "   - AZURE_TENANT_ID"
        exit 1
      fi
    # Login to Azure Container Registry
    - |
      if [ -z "$AZURE_CONTAINER_REGISTRY" ]; then
        echo "‚ö†Ô∏è  AZURE_CONTAINER_REGISTRY not set. Please configure CI/CD variable:"
        echo "   - AZURE_CONTAINER_REGISTRY (e.g., myregistry.azurecr.io or just myregistry)"
        exit 1
      fi
      # Extract registry name (remove .azurecr.io if present)
      ACR_NAME=$(echo "$AZURE_CONTAINER_REGISTRY" | sed 's/\.azurecr\.io$//')
      echo "Logging in to Azure Container Registry: $ACR_NAME"
      az acr login --name "$ACR_NAME"
      echo "‚úÖ ACR login successful"
  script:
    - echo "Building and pushing adapter container images to Azure Container Registry..."
    - |
      # Set image name and tag
      # Ensure ACR URL format (add .azurecr.io if not present)
      if [[ "$AZURE_CONTAINER_REGISTRY" == *.azurecr.io ]]; then
        ACR_URL="$AZURE_CONTAINER_REGISTRY"
      else
        ACR_URL="${AZURE_CONTAINER_REGISTRY}.azurecr.io"
      fi
      IMAGE_NAME="interface-configurator-adapters"
      IMAGE_TAG="${CI_COMMIT_REF_SLUG}-${CI_COMMIT_SHORT_SHA}"
      FULL_IMAGE_NAME="${ACR_URL}/${IMAGE_NAME}:${IMAGE_TAG}"
      LATEST_TAG="${ACR_URL}/${IMAGE_NAME}:latest"
      
      echo "Building Docker image: $FULL_IMAGE_NAME"
      echo "Dockerfile: docker/Dockerfile.adapter"
      
      # Build the Docker image
      docker build \
        -f docker/Dockerfile.adapter \
        -t "$FULL_IMAGE_NAME" \
        -t "$LATEST_TAG" \
        --build-arg BUILD_CONFIGURATION="$BUILD_CONFIGURATION" \
        .
      
      echo "‚úÖ Docker image built successfully"
      
      # Push both tags
      echo "Pushing image with tag: $IMAGE_TAG"
      docker push "$FULL_IMAGE_NAME"
      
      echo "Pushing image with tag: latest"
      docker push "$LATEST_TAG"
      
      echo "‚úÖ Adapter container images pushed successfully to ACR"
      echo ""
      echo "Image details:"
      echo "  - Tagged: $FULL_IMAGE_NAME"
      echo "  - Latest: $LATEST_TAG"
      echo "  - Registry: $AZURE_CONTAINER_REGISTRY"
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^ready\// || $CI_COMMIT_REF_NAME == "main"
      changes:
        - "adapters/**/*"
        - "main.Core/**/*"
        - "docker/**/*"
        - ".gitlab-ci.yml"
      when: on_success
  needs:
    - job: build:dotnet
      artifacts: true
    - job: test:dotnet:unit
      artifacts: false

package:dotnet:
  stage: package
  image: mcr.microsoft.com/dotnet/sdk:8.0
  dependencies:
    - build:dotnet
    - test:dotnet:unit
  script:
    - echo "Packaging .NET artifacts..."
    - mkdir -p $ARTIFACTS_PATH
    - |
      cd azure-functions/main
      dotnet publish --configuration $BUILD_CONFIGURATION --output ../../$ARTIFACTS_PATH/azure-functions
    - |
      cd main.Core
      dotnet publish --configuration $BUILD_CONFIGURATION --output ../$ARTIFACTS_PATH/main.Core
    - echo "Packaging completed"
  artifacts:
    paths:
      - $ARTIFACTS_PATH/
    expire_in: 1 week
    when: on_success
  rules:
    - if: $CI_COMMIT_REF_NAME == "main" || $CI_COMMIT_TAG

package:frontend:
  stage: package
  image: node:${NODE_VERSION}
  dependencies:
    - build:frontend
    - test:frontend
  script:
    - echo "Packaging frontend artifacts..."
    - mkdir -p $ARTIFACTS_PATH
    - cp -r frontend/dist $ARTIFACTS_PATH/frontend
    - echo "Frontend packaging completed"
  artifacts:
    paths:
      - $ARTIFACTS_PATH/frontend/
    expire_in: 1 week
    when: on_success
  rules:
    - if: $CI_COMMIT_REF_NAME == "main" || $CI_COMMIT_TAG

# ============================================
# DEPLOY STAGE (Manual - Configure as needed)
# ============================================


deploy:production:
  stage: deploy
  image: mcr.microsoft.com/dotnet/sdk:8.0
  dependencies:
    - package:dotnet
    - package:frontend
  before_script:
    - echo "Setting up deployment environment..."
    - apt-get update
    - apt-get install -y curl gnupg lsb-release
    # Install Azure CLI
    - curl -sL https://aka.ms/InstallAzureCLIDeb | bash
    # Install Azure Functions Core Tools
    - curl https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor > /etc/apt/trusted.gpg.d/microsoft.gpg
    - sh -c 'echo "deb [arch=amd64] https://packages.microsoft.com/repos/microsoft-ubuntu-$(lsb_release -cs)-prod $(lsb_release -cs) main" > /etc/apt/sources.list.d/dotnetdev.list'
    - apt-get update
    - apt-get install -y azure-functions-core-tools-4
    - echo "‚úÖ Azure Functions Core Tools installed"
    - func --version
    - echo "Logging in to Azure..."
    # Login to Azure using service principal
    - |
      if [ -n "$AZURE_CLIENT_ID" ] && [ -n "$AZURE_CLIENT_SECRET" ] && [ -n "$AZURE_TENANT_ID" ]; then
        az login --service-principal -u "$AZURE_CLIENT_ID" -p "$AZURE_CLIENT_SECRET" --tenant "$AZURE_TENANT_ID"
        if [ -n "$AZURE_SUBSCRIPTION_ID" ]; then
          az account set --subscription "$AZURE_SUBSCRIPTION_ID"
        fi
        echo "‚úÖ Azure login successful"
        az account show
      else
        echo "‚ö†Ô∏è  Azure credentials not set. Please configure CI/CD variables:"
        echo "   - AZURE_CLIENT_ID"
        echo "   - AZURE_CLIENT_SECRET"
        echo "   - AZURE_TENANT_ID"
        exit 1
      fi
  script:
    - echo "Deploying Azure Function App to production..."
    - |
      cd azure-functions/main
      echo "Step 1: Publishing Function App (--self-contained false)..."
      dotnet publish --self-contained false --configuration $BUILD_CONFIGURATION --output ./publish
      echo "‚úÖ Publish completed"
    - |
      cd azure-functions/main
      echo "Step 2: Deploying to Azure Function App..."
      if [ -z "$AZURE_FUNCTION_APP_NAME" ] || [ -z "$AZURE_RESOURCE_GROUP" ]; then
        echo "‚ö†Ô∏è  Required CI/CD variables not set:"
        echo "   - AZURE_FUNCTION_APP_NAME"
        echo "   - AZURE_RESOURCE_GROUP"
        exit 1
      fi
      echo "Function App: $AZURE_FUNCTION_APP_NAME"
      echo "Resource Group: $AZURE_RESOURCE_GROUP"
      echo "Deploying with: func azure functionapp publish --dotnet-isolated"
      func azure functionapp publish "$AZURE_FUNCTION_APP_NAME" --dotnet-isolated
      echo "‚úÖ Deployment completed successfully"
      echo ""
      echo "Function App URL: https://${AZURE_FUNCTION_APP_NAME}.azurewebsites.net"
  environment:
    name: production
    url: https://${AZURE_FUNCTION_APP_NAME}.azurewebsites.net
  rules:
    - if: $CI_COMMIT_REF_NAME == "main" || $CI_COMMIT_TAG
      when: on_success

# ============================================
# POST-DEPLOYMENT TEST STAGE
# ============================================

test:azure-functions:
  stage: test:post-deploy
  image: node:${NODE_VERSION}
  dependencies: []
  <<: *node_cache
  variables:
    CI: "true"
    AZURE_FUNCTION_APP_URL: "https://${AZURE_FUNCTION_APP_NAME}.azurewebsites.net"
  before_script:
    - echo "Installing Node.js dependencies..."
    - npm ci
    - echo "Installing Playwright browsers and system dependencies..."
    - npx playwright install --with-deps chromium
    - echo "Playwright setup completed"
    - mkdir -p test-results
    - |
      if [ -z "$AZURE_FUNCTION_APP_NAME" ]; then
        echo "‚ö†Ô∏è  AZURE_FUNCTION_APP_NAME not set. Using default URL."
        export AZURE_FUNCTION_APP_URL="https://func-integration-main.azurewebsites.net"
      else
        export AZURE_FUNCTION_APP_URL="https://${AZURE_FUNCTION_APP_NAME}.azurewebsites.net"
      fi
      echo "Testing Function App at: $AZURE_FUNCTION_APP_URL"
      export FUNCTION_APP_URL="$AZURE_FUNCTION_APP_URL"
  script:
    - echo "Running Azure Functions HTTP endpoint tests with Playwright..."
    - npx playwright test tests/end-to-end/azure-functions.spec.ts
    - echo "Azure Functions tests completed"
  artifacts:
    when: always
    paths:
      - playwright-report/
      - test-results/
    reports:
      junit: test-results/junit.xml
    expire_in: 30 days
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^ready\// || $CI_COMMIT_REF_NAME == "main" || $CI_COMMIT_TAG
      when: on_success
  needs:
    - job: deploy:production
      optional: true

test:sql-server:
  stage: test:post-deploy
  image: mcr.microsoft.com/dotnet/sdk:8.0
  dependencies:
    - build:dotnet
  <<: *dotnet_cache
  variables:
    CI: "true"
  before_script:
    - echo "Setting up SQL Server integration tests..."
    - |
      if [ -z "$AZURE_SQL_SERVER" ] || [ -z "$AZURE_SQL_DATABASE" ] || [ -z "$AZURE_SQL_USER" ] || [ -z "$AZURE_SQL_PASSWORD" ]; then
        echo "‚ö†Ô∏è  SQL Server connection details not set. Tests will be skipped."
        echo "Required CI/CD variables:"
        echo "   - AZURE_SQL_SERVER"
        echo "   - AZURE_SQL_DATABASE"
        echo "   - AZURE_SQL_USER"
        echo "   - AZURE_SQL_PASSWORD"
        exit 0
      fi
    - mkdir -p test-results
  script:
    - echo "Running SQL Server integration tests..."
    - dotnet test $TEST_PROJECT 
        --configuration $BUILD_CONFIGURATION 
        --verbosity normal
        --filter "FullyQualifiedName~SqlServerIntegrationTests"
        --logger "junit;LogFilePath=${CI_PROJECT_DIR}/test-results/junit-sql-server.xml"
    - echo "SQL Server tests completed"
  artifacts:
    when: always
    reports:
      junit: test-results/junit-sql-server.xml
    paths:
      - test-results/
    expire_in: 30 days
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^ready\// || $CI_COMMIT_REF_NAME == "main" || $CI_COMMIT_TAG
      when: on_success
  needs:
    - job: build:dotnet
      artifacts: true
    - job: deploy:production
      optional: true

test:service-bus:
  stage: test:post-deploy
  image: mcr.microsoft.com/dotnet/sdk:8.0
  dependencies:
    - build:dotnet
  <<: *dotnet_cache
  variables:
    CI: "true"
  before_script:
    - echo "Setting up Service Bus integration tests..."
    - |
      if [ -z "$AZURE_SERVICE_BUS_CONNECTION_STRING" ]; then
        echo "‚ö†Ô∏è  Service Bus connection string not set. Tests will be skipped."
        echo "Required CI/CD variable:"
        echo "   - AZURE_SERVICE_BUS_CONNECTION_STRING"
        exit 0
      fi
    - mkdir -p test-results
  script:
    - echo "Running Service Bus integration tests..."
    - dotnet test $TEST_PROJECT 
        --configuration $BUILD_CONFIGURATION 
        --verbosity normal
        --filter "FullyQualifiedName~ServiceBusIntegrationTests"
        --logger "junit;LogFilePath=${CI_PROJECT_DIR}/test-results/junit-service-bus.xml"
    - echo "Service Bus tests completed"
  artifacts:
    when: always
    reports:
      junit: test-results/junit-service-bus.xml
    paths:
      - test-results/
    expire_in: 30 days
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^ready\// || $CI_COMMIT_REF_NAME == "main" || $CI_COMMIT_TAG
      when: on_success
  needs:
    - job: build:dotnet
      artifacts: true
    - job: deploy:production
      optional: true

test:blob-storage:
  stage: test:post-deploy
  image: mcr.microsoft.com/dotnet/sdk:8.0
  dependencies:
    - build:dotnet
  <<: *dotnet_cache
  variables:
    CI: "true"
  before_script:
    - echo "Setting up Blob Storage integration tests..."
    - |
      if [ -z "$AZURE_STORAGE_CONNECTION_STRING" ] && [ -z "$MainStorageConnection" ] && [ -z "$AzureWebJobsStorage" ]; then
        echo "‚ö†Ô∏è  Blob Storage connection string not set. Tests will be skipped."
        echo "Required CI/CD variable:"
        echo "   - AZURE_STORAGE_CONNECTION_STRING (or MainStorageConnection or AzureWebJobsStorage)"
        exit 0
      fi
    - mkdir -p test-results
  script:
    - echo "Running Blob Storage integration tests..."
    - dotnet test $TEST_PROJECT 
        --configuration $BUILD_CONFIGURATION 
        --verbosity normal
        --filter "FullyQualifiedName~BlobStorageIntegrationTests"
        --logger "junit;LogFilePath=${CI_PROJECT_DIR}/test-results/junit-blob-storage.xml"
    - echo "Blob Storage tests completed"
  artifacts:
    when: always
    reports:
      junit: test-results/junit-blob-storage.xml
    paths:
      - test-results/
    expire_in: 30 days
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^ready\// || $CI_COMMIT_REF_NAME == "main" || $CI_COMMIT_TAG
      when: on_success
  needs:
    - job: build:dotnet
      artifacts: true
    - job: deploy:production
      optional: true

test:container-apps:
  stage: test:post-deploy
  image: mcr.microsoft.com/dotnet/sdk:8.0
  dependencies:
    - build:dotnet
  <<: *dotnet_cache
  variables:
    CI: "true"
  before_script:
    - echo "Setting up Container Apps integration tests..."
    - |
      if [ -z "$AZURE_RESOURCE_GROUP" ] || [ -z "$AZURE_SUBSCRIPTION_ID" ]; then
        echo "‚ö†Ô∏è  Azure resource information not set. Tests will be skipped."
        echo "Required CI/CD variables:"
        echo "   - AZURE_RESOURCE_GROUP"
        echo "   - AZURE_SUBSCRIPTION_ID"
        exit 0
      fi
    - mkdir -p test-results
  script:
    - echo "Running Container Apps integration tests..."
    - dotnet test $TEST_PROJECT 
        --configuration $BUILD_CONFIGURATION 
        --verbosity normal
        --filter "FullyQualifiedName~ContainerAppIntegrationTests"
        --logger "junit;LogFilePath=${CI_PROJECT_DIR}/test-results/junit-container-apps.xml"
    - echo "Container Apps tests completed"
  artifacts:
    when: always
    reports:
      junit: test-results/junit-container-apps.xml
    paths:
      - test-results/
    expire_in: 30 days
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^ready\// || $CI_COMMIT_REF_NAME == "main" || $CI_COMMIT_TAG
      when: on_success
  needs:
    - job: build:dotnet
      artifacts: true
    - job: deploy:production
      optional: true

test:container-registry:
  stage: test:post-deploy
  image: mcr.microsoft.com/dotnet/sdk:8.0
  dependencies:
    - build:dotnet
  <<: *dotnet_cache
  variables:
    CI: "true"
  before_script:
    - echo "Setting up Container Registry integration tests..."
    - |
      if [ -z "$AZURE_CONTAINER_REGISTRY" ]; then
        echo "‚ö†Ô∏è  Container Registry name not set. Tests will be skipped."
        echo "Required CI/CD variable:"
        echo "   - AZURE_CONTAINER_REGISTRY"
        exit 0
      fi
    - mkdir -p test-results
  script:
    - echo "Running Container Registry integration tests..."
    - dotnet test $TEST_PROJECT 
        --configuration $BUILD_CONFIGURATION 
        --verbosity normal
        --filter "FullyQualifiedName~ContainerRegistryIntegrationTests"
        --logger "junit;LogFilePath=${CI_PROJECT_DIR}/test-results/junit-container-registry.xml"
    - echo "Container Registry tests completed"
  artifacts:
    when: always
    reports:
      junit: test-results/junit-container-registry.xml
    paths:
      - test-results/
    expire_in: 30 days
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^ready\// || $CI_COMMIT_REF_NAME == "main" || $CI_COMMIT_TAG
      when: on_success
  needs:
    - job: build:dotnet
      artifacts: true
    - job: package:adapter-containers
      optional: true

test:static-web-app:
  stage: test:post-deploy
  image: node:${NODE_VERSION}
  dependencies: []
  <<: *node_cache
  variables:
    CI: "true"
    STATIC_WEB_APP_URL: "${STATIC_WEB_APP_URL:-https://interface-configurator.vercel.app}"
  before_script:
    - echo "Installing Node.js dependencies..."
    - npm ci
    - echo "Installing Playwright browsers and system dependencies..."
    - npx playwright install --with-deps chromium
    - echo "Playwright setup completed"
    - mkdir -p test-results
    - |
      if [ -z "$STATIC_WEB_APP_URL" ]; then
        echo "‚ö†Ô∏è  STATIC_WEB_APP_URL not set. Using default."
        export STATIC_WEB_APP_URL="https://interface-configurator.vercel.app"
      fi
      echo "Testing Static Web App at: $STATIC_WEB_APP_URL"
  script:
    - echo "Running Static Web App E2E tests with Playwright..."
    - npx playwright test tests/end-to-end/static-web-app.spec.ts
    - echo "Static Web App tests completed"
  artifacts:
    when: always
    paths:
      - playwright-report/
      - test-results/
    reports:
      junit: test-results/junit.xml
    expire_in: 30 days
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^ready\// || $CI_COMMIT_REF_NAME == "main" || $CI_COMMIT_TAG
      when: on_success
  needs:
    - job: deploy:vercel
      optional: true
    - job: deploy:azure-static-web-app
      optional: true

test:adapter-pipeline:
  stage: test:post-deploy
  image: mcr.microsoft.com/dotnet/sdk:8.0
  dependencies:
    - build:dotnet
  <<: *dotnet_cache
  variables:
    CI: "true"
  before_script:
    - echo "Setting up Adapter Pipeline integration tests..."
    - |
      if [ -z "$AZURE_SERVICE_BUS_CONNECTION_STRING" ] || [ -z "$AZURE_STORAGE_CONNECTION_STRING" ] || \
         [ -z "$AZURE_SQL_SERVER" ] || [ -z "$AZURE_SQL_DATABASE" ] || [ -z "$AZURE_SQL_USER" ] || [ -z "$AZURE_SQL_PASSWORD" ]; then
        echo "‚ö†Ô∏è  Required connection strings not set. Tests will be skipped."
        echo "Required CI/CD variables:"
        echo "   - AZURE_SERVICE_BUS_CONNECTION_STRING"
        echo "   - AZURE_STORAGE_CONNECTION_STRING"
        echo "   - AZURE_SQL_SERVER, AZURE_SQL_DATABASE, AZURE_SQL_USER, AZURE_SQL_PASSWORD"
        exit 0
      fi
    - mkdir -p test-results
  script:
    - echo "Running Adapter Pipeline end-to-end tests..."
    - dotnet test $TEST_PROJECT 
        --configuration $BUILD_CONFIGURATION 
        --verbosity normal
        --filter "FullyQualifiedName~AdapterPipelineIntegrationTests"
        --logger "junit;LogFilePath=${CI_PROJECT_DIR}/test-results/junit-adapter-pipeline.xml"
    - echo "Adapter Pipeline tests completed"
  artifacts:
    when: always
    reports:
      junit: test-results/junit-adapter-pipeline.xml
    paths:
      - test-results/
    expire_in: 30 days
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^ready\// || $CI_COMMIT_REF_NAME == "main" || $CI_COMMIT_TAG
      when: on_success
  needs:
    - job: build:dotnet
      artifacts: true
    - job: deploy:production
      optional: true
    - job: package:adapter-containers
      optional: true

deploy:vercel:
  stage: deploy
  image: node:22
  dependencies:
    - package:frontend
  before_script:
    - echo "Setting up Vercel deployment..."
    - npm install -g vercel@latest
    - vercel --version
  script:
    - echo "Deploying static web app to Vercel..."
    - |
      if [ -z "$VERCEL_TOKEN" ]; then
        echo "‚ö†Ô∏è  VERCEL_TOKEN not set. Please configure CI/CD variable:"
        echo "   - VERCEL_TOKEN (get from https://vercel.com/account/tokens)"
        exit 1
      fi
    - |
      # Set Vercel environment variables
      export VERCEL_ORG_ID="${VERCEL_ORG_ID:-}"
      export VERCEL_PROJECT_ID="${VERCEL_PROJECT_ID:-}"
      
      # Deploy to Vercel production
      echo "Deploying to Vercel production..."
      vercel deploy --prod --token "$VERCEL_TOKEN" --yes
      
      if [ $? -eq 0 ]; then
        echo "‚úÖ Vercel deployment completed successfully"
      else
        echo "‚ùå Vercel deployment failed"
        exit 1
      fi
  environment:
    name: vercel-production
    url: https://${VERCEL_PROJECT_NAME:-interface-configurator}.vercel.app
  rules:
    - if: $CI_COMMIT_REF_NAME == "main" || $CI_COMMIT_TAG
      when: on_success

deploy:azure-static-web-app:
  stage: deploy
  image: node:22
  dependencies:
    - package:frontend
  before_script:
    - echo "Setting up Azure Static Web App deployment..."
    - echo "Installing Azure CLI..."
    - apt-get update
    - apt-get install -y curl gnupg lsb-release ca-certificates
    - curl -sL https://aka.ms/InstallAzureCLIDeb | bash
    - az --version
    - echo "Installing Azure Static Web Apps CLI..."
    - npm install -g @azure/static-web-apps-cli
    - swa --version
    - echo "Logging in to Azure..."
    - |
      if [ -n "$AZURE_CLIENT_ID" ] && [ -n "$AZURE_CLIENT_SECRET" ] && [ -n "$AZURE_TENANT_ID" ]; then
        az login --service-principal -u "$AZURE_CLIENT_ID" -p "$AZURE_CLIENT_SECRET" --tenant "$AZURE_TENANT_ID"
        if [ -n "$AZURE_SUBSCRIPTION_ID" ]; then
          az account set --subscription "$AZURE_SUBSCRIPTION_ID"
        fi
        echo "‚úÖ Azure login successful"
        az account show
      else
        echo "‚ö†Ô∏è  Azure credentials not set. Please configure CI/CD variables:"
        echo "   - AZURE_CLIENT_ID"
        echo "   - AZURE_CLIENT_SECRET"
        echo "   - AZURE_TENANT_ID"
        exit 1
      fi
  script:
    - echo "Deploying static web app to Azure Static Web Apps..."
    - |
      if [ -z "$AZURE_STATIC_WEB_APP_NAME" ] || [ -z "$AZURE_RESOURCE_GROUP" ]; then
        echo "‚ö†Ô∏è  Required CI/CD variables not set:"
        echo "   - AZURE_STATIC_WEB_APP_NAME"
        echo "   - AZURE_RESOURCE_GROUP"
        exit 1
      fi
    - |
      # Get deployment token - prefer CI/CD variable, otherwise retrieve from Azure
      if [ -n "$DEPLOYMENT_TOKEN" ]; then
        FINAL_DEPLOYMENT_TOKEN="$DEPLOYMENT_TOKEN"
        echo "‚úÖ Using deployment token from CI/CD variable"
      else
        echo "Retrieving deployment token from Azure Static Web App..."
        RETRIEVED_TOKEN=$(az staticwebapp secrets list \
          --name "$AZURE_STATIC_WEB_APP_NAME" \
          --resource-group "$AZURE_RESOURCE_GROUP" \
          --query "properties.apiKey" -o tsv 2>/dev/null || echo "")
        
        if [ -z "$RETRIEVED_TOKEN" ]; then
          echo "‚ö†Ô∏è  Could not retrieve deployment token via secrets. Trying alternative method..."
          # Alternative: Get from app settings
          RETRIEVED_TOKEN=$(az staticwebapp appsettings list \
            --name "$AZURE_STATIC_WEB_APP_NAME" \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --query "[?name=='DEPLOYMENT_TOKEN'].value" -o tsv 2>/dev/null || echo "")
        fi
        
        if [ -z "$RETRIEVED_TOKEN" ]; then
          echo "‚ùå Could not retrieve deployment token from Azure"
          echo "   Please set DEPLOYMENT_TOKEN as a CI/CD variable"
          echo "   Or ensure the Azure Static Web App has a deployment token configured"
          exit 1
        fi
        
        FINAL_DEPLOYMENT_TOKEN="$RETRIEVED_TOKEN"
        echo "‚úÖ Using deployment token retrieved from Azure"
      fi
    - |
      # Deploy using SWA CLI
      echo "Deploying to Azure Static Web App..."
      echo "Static Web App: $AZURE_STATIC_WEB_APP_NAME"
      echo "Resource Group: $AZURE_RESOURCE_GROUP"
      
      # Use the packaged frontend artifacts
      # The artifacts are in $ARTIFACTS_PATH/frontend/dist/ from package:frontend job
      # package:frontend copies frontend/dist to $ARTIFACTS_PATH/frontend
      # So the structure is: $ARTIFACTS_PATH/frontend/dist/interface-configuration/browser
      ARTIFACTS_BASE="${ARTIFACTS_PATH:-artifacts}/frontend/dist"
      BROWSER_DIR="$ARTIFACTS_BASE/interface-configuration/browser"
      
      if [ ! -d "$BROWSER_DIR" ]; then
        echo "‚ö†Ô∏è  Frontend artifacts not found at $BROWSER_DIR"
        echo "   Building frontend now..."
        cd frontend
        npm ci
        npm run build:prod
        BROWSER_DIR="frontend/dist/interface-configuration/browser"
      fi
      
      echo "Deploying from: $BROWSER_DIR"
      
      # Deploy using SWA CLI
      swa deploy "$BROWSER_DIR" \
        --app-name "$AZURE_STATIC_WEB_APP_NAME" \
        --resource-group "$AZURE_RESOURCE_GROUP" \
        --deployment-token "$FINAL_DEPLOYMENT_TOKEN" \
        --env production \
        --no-use-keychain
      
      if [ $? -eq 0 ]; then
        echo "‚úÖ Azure Static Web App deployment completed successfully"
        echo ""
        echo "Static Web App URL: https://${AZURE_STATIC_WEB_APP_NAME}.azurestaticapps.net"
      else
        echo "‚ùå Azure Static Web App deployment failed"
        exit 1
      fi
  environment:
    name: azure-static-web-app-production
    url: https://${AZURE_STATIC_WEB_APP_NAME}.azurestaticapps.net
  rules:
    - if: $CI_COMMIT_REF_NAME == "main" || $CI_COMMIT_TAG
      when: on_success

# ============================================
# CLEANUP
# ============================================

cleanup:delete-merged-ready-branch:
  stage: deploy
  image: curlimages/curl:latest
  variables:
    CI: "true"
  before_script:
    - apk add --no-cache git || true
  script:
    - |
      echo "Cleaning up merged ready/* branch..."
      
      # Only run if this is a merge to main
      if [ "$CI_COMMIT_REF_NAME" != "main" ]; then
        echo "Not on main branch, skipping cleanup"
        exit 0
      fi
      
      # Try multiple methods to detect merged branch
      SOURCE_BRANCH=""
      
      # Method 1: Check merge commit message (GitLab format)
      if git log -1 --pretty=%B | grep -q "Merge branch"; then
        SOURCE_BRANCH=$(git log -1 --pretty=%B | grep -oP "Merge branch ['\"]\Kready/[^'\"]+" | head -1 || echo "")
      fi
      
      # Method 2: Check if merge commit has two parents (indicates merge)
      PARENT_COUNT=$(git log -1 --pretty=%P | wc -w)
      if [ "$PARENT_COUNT" -eq 2 ]; then
        # Get the second parent (the merged branch)
        MERGED_BRANCH=$(git log -1 --pretty=%P | awk '{print $2}')
        if [ -n "$MERGED_BRANCH" ]; then
          # Try to find branch name from commit
          SOURCE_BRANCH=$(git branch -r --contains $MERGED_BRANCH | grep "ready/" | head -1 | sed 's|origin/||' | xargs || echo "")
        fi
      fi
      
      # Method 3: Check recent merge requests via API (if token available)
      if [ -z "$SOURCE_BRANCH" ] && [ -n "$GITLAB_TOKEN" ] && [ -n "$CI_PROJECT_ID" ]; then
        echo "Checking recent merge requests via API..."
        RECENT_MR=$(curl -s --header "PRIVATE-TOKEN: $GITLAB_TOKEN" \
          "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests?state=merged&target_branch=main&per_page=1" | \
          grep -oP '"source_branch":"\Kready/[^"]+' | head -1 || echo "")
        if [ -n "$RECENT_MR" ]; then
          SOURCE_BRANCH="$RECENT_MR"
        fi
      fi
      
      # If we found a ready/* branch, delete it
      if [[ "$SOURCE_BRANCH" =~ ^ready/ ]]; then
        echo "Found ready/* branch to delete: $SOURCE_BRANCH"
        
        # Delete branch using GitLab API
        if [ -n "$GITLAB_TOKEN" ] && [ -n "$CI_PROJECT_ID" ]; then
          echo "Deleting branch $SOURCE_BRANCH from origin..."
          DELETE_RESPONSE=$(curl -s -w "\n%{http_code}" -X DELETE \
            --header "PRIVATE-TOKEN: $GITLAB_TOKEN" \
            "$CI_API_V4_URL/projects/$CI_PROJECT_ID/repository/branches/$(echo $SOURCE_BRANCH | sed 's|/|%2F|g')")
          
          HTTP_CODE=$(echo "$DELETE_RESPONSE" | tail -1)
          if [ "$HTTP_CODE" = "204" ] || [ "$HTTP_CODE" = "200" ]; then
            echo "‚úÖ Branch $SOURCE_BRANCH deleted successfully"
          elif [ "$HTTP_CODE" = "404" ]; then
            echo "‚ÑπÔ∏è  Branch $SOURCE_BRANCH already deleted or doesn't exist"
          else
            echo "‚ö†Ô∏è  Failed to delete branch (HTTP $HTTP_CODE)"
            echo "   Response: $(echo "$DELETE_RESPONSE" | head -n -1)"
          fi
        else
          echo "‚ö†Ô∏è  GITLAB_TOKEN not set. Cannot delete branch automatically."
          echo "   Branch $SOURCE_BRANCH should be deleted via merge request settings"
          echo "   Or set GITLAB_TOKEN in CI/CD Variables"
        fi
      else
        echo "‚ÑπÔ∏è  No ready/* branch detected to delete"
        echo "   (This is normal if branch was already deleted or merge used different method)"
      fi
  rules:
    - if: $CI_COMMIT_REF_NAME == "main"
      when: on_success
  allow_failure: true
  needs:
    - job: package:dotnet
      optional: true
    - job: package:frontend
      optional: true

# ============================================
# NOTIFICATIONS
# ============================================

notify:email:on-failure:
  stage: test
  image: alpine:latest
  variables:
    CI: "true"
  before_script:
    - apk add --no-cache curl jq bash
  script:
    - |
      echo "Sending failure notification email to commit author..."
      
      # Only run for ready/* branches
      if [[ ! "$CI_COMMIT_REF_NAME" =~ ^ready/ ]]; then
        echo "Not a ready/* branch, skipping email notification"
        exit 0
      fi
      
      # Get commit author email from GitLab API
      if [ -z "$GITLAB_TOKEN" ]; then
        echo "‚ö†Ô∏è  GITLAB_TOKEN not set. Cannot retrieve commit author email."
        echo "   Email notification will be skipped."
        exit 0
      fi
      
      echo "Fetching commit author information..."
      COMMIT_INFO=$(curl -s --header "PRIVATE-TOKEN: $GITLAB_TOKEN" \
        "$CI_API_V4_URL/projects/$CI_PROJECT_ID/repository/commits/$CI_COMMIT_SHA")
      
      AUTHOR_EMAIL=$(echo "$COMMIT_INFO" | jq -r '.author_email // empty')
      AUTHOR_NAME=$(echo "$COMMIT_INFO" | jq -r '.author_name // "Developer"')
      
      if [ -z "$AUTHOR_EMAIL" ] || [ "$AUTHOR_EMAIL" == "null" ]; then
        echo "‚ö†Ô∏è  Could not retrieve commit author email from GitLab API"
        echo "   Commit info: $COMMIT_INFO"
        exit 0
      fi
      
      echo "Commit author: $AUTHOR_NAME <$AUTHOR_EMAIL>"
      echo "Branch: $CI_COMMIT_REF_NAME"
      echo "Pipeline: $CI_PIPELINE_ID"
      
      # Build email content
      PIPELINE_URL="${CI_PROJECT_URL}/-/pipelines/${CI_PIPELINE_ID}"
      BRANCH_NAME="${CI_COMMIT_REF_NAME}"
      PROJECT_NAME="${CI_PROJECT_NAME}"
      
      SUBJECT="üö® Pipeline Failed: ${BRANCH_NAME} - ${PROJECT_NAME}"
      COMMIT_MSG=$(echo "$COMMIT_INFO" | jq -r '.message // "N/A"' | head -1)
      MESSAGE=$(printf "Pipeline failed for your ready branch: %s\n\nProject: %s\nBranch: %s\nPipeline ID: %s\nPipeline URL: %s\nCommit: %s\nCommit Message: %s\n\nPlease check the pipeline logs and fix the issues.\n\nPipeline URL: %s\n" \
        "${BRANCH_NAME}" \
        "${PROJECT_NAME}" \
        "${BRANCH_NAME}" \
        "${CI_PIPELINE_ID}" \
        "${PIPELINE_URL}" \
        "${CI_COMMIT_SHORT_SHA}" \
        "${COMMIT_MSG}" \
        "${PIPELINE_URL}")
      
      # Send email via configured email service
      if [ -n "$EMAIL_API_URL" ] && [ -n "$EMAIL_API_KEY" ]; then
        echo "Sending email to $AUTHOR_EMAIL via email service API..."
        
        # Construct email payload (adjust based on your email service API)
        EMAIL_PAYLOAD=$(jq -n \
          --arg to "$AUTHOR_EMAIL" \
          --arg subject "$SUBJECT" \
          --arg body "$MESSAGE" \
          '{
            "to": $to,
            "subject": $subject,
            "body": $body,
            "from": "noreply@gitlab-ci"
          }')
        
        HTTP_CODE=$(curl -s -w "\n%{http_code}" -X POST "$EMAIL_API_URL" \
          -H "Authorization: Bearer $EMAIL_API_KEY" \
          -H "Content-Type: application/json" \
          -d "$EMAIL_PAYLOAD" | tail -1)
        
        if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "201" ] || [ "$HTTP_CODE" = "202" ]; then
          echo "‚úÖ Email sent successfully to $AUTHOR_EMAIL"
        else
          echo "‚ö†Ô∏è  Email sending failed (HTTP $HTTP_CODE)"
          echo "   Email would have been sent to: $AUTHOR_EMAIL"
        fi
      elif [ -n "$SMTP_HOST" ] && [ -n "$SMTP_USER" ] && [ -n "$SMTP_PASSWORD" ]; then
        echo "Sending email via SMTP to $AUTHOR_EMAIL..."
        
        # Use sendmail or similar (if available) or curl with SMTP
        # For simplicity, we'll use a basic SMTP approach
        # Note: This requires additional tools. For production, use a proper email service.
        echo "‚ö†Ô∏è  Direct SMTP sending not implemented. Please use EMAIL_API_URL or configure GitLab project notifications."
        echo "   Email would have been sent to: $AUTHOR_EMAIL"
      else
        echo "‚ö†Ô∏è  Email service not configured. Please set one of:"
        echo "   Option 1: EMAIL_API_URL and EMAIL_API_KEY (for email service API)"
        echo "   Option 2: SMTP_HOST, SMTP_USER, SMTP_PASSWORD (for SMTP)"
        echo "   Option 3: Configure GitLab project-level email notifications"
        echo ""
        echo "   Email would have been sent to: $AUTHOR_EMAIL"
        echo "   Subject: $SUBJECT"
        echo "   Pipeline URL: $PIPELINE_URL"
      fi
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^ready\//
      when: on_failure  # Only run when previous jobs fail
  allow_failure: false  # Don't allow failures - email notification is critical
  needs:
    - job: build:dotnet
      optional: true
    - job: test:dotnet:unit
      optional: true
    - job: test:frontend
      optional: true
    - job: test:e2e
      optional: true

notify:sms:
  stage: test
  image: curlimages/curl:latest
  variables:
    CI: "true"
  script:
    - |
      echo "Sending SMS notification for test failures..."
      # Extract branch name
      BRANCH_NAME="${CI_COMMIT_REF_NAME}"
      PIPELINE_URL="${CI_PROJECT_URL}/-/pipelines/${CI_PIPELINE_ID}"
      
      # SMS message
      MESSAGE="üö® Test failures in ready branch: ${BRANCH_NAME}. Pipeline: ${PIPELINE_URL}"
      
      # Send SMS via API (configure your SMS service)
      # Example using generic HTTP API
      if [ -n "$SMS_API_URL" ] && [ -n "$SMS_API_KEY" ] && [ -n "$SMS_PHONE_NUMBER" ]; then
        curl -X POST "$SMS_API_URL" \
          -H "Authorization: Bearer $SMS_API_KEY" \
          -H "Content-Type: application/json" \
          -d "{
            \"to\": \"$SMS_PHONE_NUMBER\",
            \"message\": \"$MESSAGE\"
          }" || echo "SMS sending failed, but continuing..."
      else
        echo "SMS variables not configured. Skipping SMS notification."
        echo "To enable SMS, set: SMS_API_URL, SMS_API_KEY, SMS_PHONE_NUMBER"
      fi
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^ready\//
      when: on_failure  # Only run when previous jobs fail
  allow_failure: true  # Don't block pipeline if SMS fails
  needs:
    - job: test:dotnet:unit
      optional: true
    - job: test:frontend
      optional: true
    - job: test:e2e
      optional: true

# ============================================
# CODE QUALITY (Optional)
# ============================================

lint:dotnet:
  stage: test
  image: mcr.microsoft.com/dotnet/sdk:8.0
  <<: *dotnet_cache
  script:
    - echo "Running .NET code analysis..."
    - dotnet format $SOLUTION_PATH --verify-no-changes --verbosity diagnostic || true
    - echo "Code analysis completed"
  allow_failure: true
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^ready\// || $CI_COMMIT_REF_NAME == "main"
      changes:
        - "azure-functions/**/*.cs"
        - "main.Core/**/*.cs"
        - "adapters/**/*.cs"
        - ".gitlab-ci.yml"

lint:frontend:
  stage: test
  image: node:${NODE_VERSION}
  <<: *node_cache
  before_script:
    - cd $FRONTEND_PATH
    - npm ci
  script:
    - echo "Running frontend linting..."
    - npm run lint || true
    - echo "Linting completed"
  allow_failure: true
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^ready\// || $CI_COMMIT_REF_NAME == "main"
      changes:
        - "frontend/**/*.ts"
        - "frontend/**/*.html"
        - ".gitlab-ci.yml"

# ============================================
# VERSION BUMP STAGE - Auto version bumping
# ============================================

version:bump:
  stage: version
  image: node:${NODE_VERSION}
  variables:
    GIT_STRATEGY: clone
    GIT_DEPTH: 0
  before_script:
    - apk add --no-cache git sed || true
    - git config --global user.email "gitlab-ci@noreply.gitlab.com"
    - git config --global user.name "GitLab CI"
  script:
    - |
      echo "Checking if commit is from version bump..."
      COMMIT_MSG=$(git log -1 --pretty=%B)
      if [[ "$COMMIT_MSG" == "chore: bump version"* ]]; then
        echo "‚ö†Ô∏è  Commit is from version bump, skipping to avoid infinite loop"
        exit 0
      fi
      
      echo "Reading current version..."
      if [ -f version.json ]; then
        CURRENT_VERSION=$(node -p "require('./version.json').version")
        CURRENT_BUILD=$(node -p "require('./version.json').buildNumber")
        echo "Current version: $CURRENT_VERSION"
        echo "Current build: $CURRENT_BUILD"
      else
        CURRENT_VERSION="1.0.0"
        CURRENT_BUILD=0
        echo "No version.json found, starting with version: $CURRENT_VERSION"
      fi
      
      # Increment build number
      NEW_BUILD=$((CURRENT_BUILD + 1))
      
      # Parse version (e.g., "1.2.3")
      IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
      MAJOR=${VERSION_PARTS[0]}
      MINOR=${VERSION_PARTS[1]}
      PATCH=${VERSION_PARTS[2]}
      
      # Increment patch version
      NEW_PATCH=$((PATCH + 1))
      NEW_VERSION="$MAJOR.$MINOR.$NEW_PATCH"
      
      echo "New version: $NEW_VERSION"
      echo "New build: $NEW_BUILD"
      
      # Update version.json
      cat > version.json << EOF
      {
        "version": "$NEW_VERSION",
        "buildNumber": $NEW_BUILD,
        "lastUpdated": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
      }
      EOF
      
      # Update root package.json
      if [ -f package.json ]; then
        node -e "
          const fs = require('fs');
          const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
          pkg.version = '$NEW_VERSION';
          fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\n');
        "
      fi
      
      # Update frontend package.json
      if [ -f frontend/package.json ]; then
        node -e "
          const fs = require('fs');
          const pkg = JSON.parse(fs.readFileSync('frontend/package.json', 'utf8'));
          pkg.version = '$NEW_VERSION';
          fs.writeFileSync('frontend/package.json', JSON.stringify(pkg, null, 2) + '\n');
        "
      fi
      
      # Update Azure Functions .csproj if it has a Version property
      if [ -f azure-functions/main/main.csproj ]; then
        sed -i "s/<Version>.*<\/Version>/<Version>$NEW_VERSION<\/Version>/g" azure-functions/main/main.csproj || true
      fi
      
      # Copy version.json to frontend assets
      mkdir -p frontend/src/assets
      cp version.json frontend/src/assets/version.json || true
      
      echo "Committing version bump..."
      git add version.json package.json frontend/package.json azure-functions/main/main.csproj frontend/src/assets/version.json 2>/dev/null || true
      git commit -m "chore: bump version to $NEW_VERSION (build $NEW_BUILD)" || exit 0
      
      echo "Pushing version bump to GitLab..."
      git push origin HEAD:${CI_COMMIT_REF_NAME} || {
        echo "‚ö†Ô∏è  Failed to push to GitLab, but continuing..."
        exit 0
      }
      
      # Also push to GitHub if configured
      if [ -n "$GITHUB_REPO_URL" ]; then
        echo "Pushing version bump to GitHub..."
        if [[ "$GITHUB_REPO_URL" == *"@"* ]]; then
          # SSH URL
          git remote add github "$GITHUB_REPO_URL" 2>/dev/null || git remote set-url github "$GITHUB_REPO_URL"
        else
          # HTTPS URL - use token if provided
          if [ -n "$GITHUB_TOKEN" ]; then
            GITHUB_URL_WITH_TOKEN=$(echo "$GITHUB_REPO_URL" | sed "s|https://|https://${GITHUB_TOKEN}@|")
            git remote add github "$GITHUB_URL_WITH_TOKEN" 2>/dev/null || git remote set-url github "$GITHUB_URL_WITH_TOKEN"
          else
            git remote add github "$GITHUB_REPO_URL" 2>/dev/null || git remote set-url github "$GITHUB_REPO_URL"
          fi
        fi
        git push github HEAD:${CI_COMMIT_REF_NAME} || {
          echo "‚ö†Ô∏è  Failed to push to GitHub, but continuing..."
        }
      fi
      
      echo "‚úÖ Version bumped to $NEW_VERSION (build $NEW_BUILD)"
  rules:
    - if: $CI_COMMIT_REF_NAME == "main"
      changes:
        - "azure-functions/**/*"
        - "main.Core/**/*"
        - "adapters/**/*"
        - "services/**/*"
        - "frontend/**/*"
        - "package.json"
        - ".gitlab-ci.yml"
      exists:
        - "version.json"
  needs:
    - job: test:dotnet:unit
      optional: true
    - job: test:frontend
      optional: true
  allow_failure: false

