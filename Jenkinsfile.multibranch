// Multi-branch Pipeline for Jenkins
// Supports feature branches, develop, and main branches

pipeline {
    agent any
    
    options {
        timeout(time: 30, unit: 'MINUTES')
        buildDiscarder(logRotator(numToKeepStr: '20'))
        timestamps()
        ansiColor('xterm')
        skipDefaultCheckout(false)
    }
    
    environment {
        NODE_VERSION = '22.0.0'
        NPM_VERSION = '10.0.0'
        COVERAGE_THRESHOLD = '70'
        BRANCH_NAME = "${env.BRANCH_NAME ?: 'unknown'}"
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
                script {
                    env.GIT_COMMIT_SHORT = sh(
                        script: 'git rev-parse --short HEAD',
                        returnStdout: true
                    ).trim()
                    env.GIT_BRANCH = sh(
                        script: 'git rev-parse --abbrev-ref HEAD',
                        returnStdout: true
                    ).trim()
                    echo "Branch: ${env.GIT_BRANCH}"
                    echo "Commit: ${env.GIT_COMMIT_SHORT}"
                }
            }
        }
        
        stage('Environment Setup') {
            steps {
                sh '''
                    echo "Node version:"
                    node --version
                    echo "NPM version:"
                    npm --version
                '''
            }
        }
        
        stage('Install Dependencies') {
            steps {
                sh '''
                    echo "Installing root dependencies..."
                    npm ci --prefer-offline --no-audit || true
                    
                    echo "Installing frontend dependencies..."
                    cd frontend
                    npm ci --prefer-offline --no-audit
                '''
            }
        }
        
        stage('Build') {
            steps {
                sh '''
                    cd frontend
                    npm run build
                '''
                archiveArtifacts artifacts: 'frontend/dist/**/*', fingerprint: true
            }
        }
        
        stage('Unit Tests') {
            parallel {
                stage('Run Tests') {
                    steps {
                        sh '''
                            cd frontend
                            npm test -- --code-coverage --browsers=ChromeHeadless --watch=false
                        '''
                    }
                }
                
                stage('Coverage Check') {
                    steps {
                        script {
                            dir('frontend') {
                                def coverageFile = 'coverage/interface-configurator/coverage-summary.json'
                                if (fileExists(coverageFile)) {
                                    def coverage = readJSON file: coverageFile
                                    def statements = coverage.total.statements.pct
                                    def branches = coverage.total.branches.pct
                                    def functions = coverage.total.functions.pct
                                    def lines = coverage.total.lines.pct
                                    
                                    // Store coverage for later use
                                    env.COVERAGE_STATEMENTS = statements.toString()
                                    env.COVERAGE_BRANCHES = branches.toString()
                                    env.COVERAGE_FUNCTIONS = functions.toString()
                                    env.COVERAGE_LINES = lines.toString()
                                    
                                    // Check thresholds (only enforce on main/develop)
                                    if (env.BRANCH_NAME == 'main' || env.BRANCH_NAME == 'develop') {
                                        if (statements < env.COVERAGE_THRESHOLD.toFloat() ||
                                            branches < 65 ||
                                            functions < env.COVERAGE_THRESHOLD.toFloat() ||
                                            lines < env.COVERAGE_THRESHOLD.toFloat()) {
                                            error("Coverage thresholds not met!")
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            post {
                always {
                    publishHTML([
                        reportDir: 'frontend/coverage/interface-configurator',
                        reportFiles: 'index.html',
                        reportName: 'Coverage Report',
                        keepAll: true
                    ])
                }
            }
        }
        
        stage('E2E Tests') {
            when {
                anyOf {
                    branch 'main'
                    branch 'develop'
                    expression { env.CHANGE_TARGET == 'main' || env.CHANGE_TARGET == 'develop' }
                }
            }
            steps {
                sh '''
                    echo "Installing Playwright browsers..."
                    npx playwright install --with-deps chromium
                    
                    echo "Running E2E tests..."
                    npm run test:e2e
                '''
            }
            post {
                always {
                    publishHTML([
                        reportDir: 'playwright-report',
                        reportFiles: 'index.html',
                        reportName: 'E2E Test Report',
                        keepAll: true
                    ])
                    junit 'test-results/junit.xml'
                    archiveArtifacts artifacts: 'test-results/**/*', allowEmptyArchive: true
                }
            }
        }
        
        stage('Visual Regression') {
            when {
                branch 'main'
            }
            steps {
                sh '''
                    echo "Running visual regression tests..."
                    npx playwright test e2e/visual-regression.spec.ts
                '''
            }
            post {
                always {
                    archiveArtifacts artifacts: 'test-results/**/*.png', allowEmptyArchive: true
                }
            }
        }
        
        stage('Deploy') {
            when {
                anyOf {
                    branch 'main'
                    branch 'develop'
                }
            }
            steps {
                script {
                    if (env.BRANCH_NAME == 'main') {
                        echo "Deploying to production..."
                        // sh 'vercel deploy --prod'
                    } else if (env.BRANCH_NAME == 'develop') {
                        echo "Deploying preview..."
                        // sh 'vercel deploy --preview'
                    }
                }
            }
        }
    }
    
    post {
        always {
            script {
                // Generate test summary
                def summary = """
# Test Execution Summary

**Branch:** ${env.GIT_BRANCH}
**Commit:** ${env.GIT_COMMIT_SHORT}
**Build:** #${env.BUILD_NUMBER}

## Coverage
- Statements: ${env.COVERAGE_STATEMENTS ?: 'N/A'}%
- Branches: ${env.COVERAGE_BRANCHES ?: 'N/A'}%
- Functions: ${env.COVERAGE_FUNCTIONS ?: 'N/A'}%
- Lines: ${env.COVERAGE_LINES ?: 'N/A'}%

## Test Results
- Unit Tests: ${currentBuild.result == 'SUCCESS' ? '✅ Passed' : '❌ Failed'}
- E2E Tests: ${env.BRANCH_NAME in ['main', 'develop'] ? '✅ Passed' : '⏭️ Skipped'}
"""
                writeFile file: 'test-summary.md', text: summary
                archiveArtifacts artifacts: 'test-summary.md', allowEmptyArchive: true
            }
        }
        success {
            script {
                echo "✅ Pipeline succeeded!"
            }
        }
        failure {
            script {
                echo "❌ Pipeline failed!"
            }
        }
    }
}
